"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/micromark-extension-gfm-table";
exports.ids = ["vendor-chunks/micromark-extension-gfm-table"];
exports.modules = {

/***/ "(ssr)/./node_modules/micromark-extension-gfm-table/dev/lib/edit-map.js":
/*!************************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-table/dev/lib/edit-map.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EditMap: () => (/* binding */ EditMap)\n/* harmony export */ });\n/**\n * @typedef {import('micromark-util-types').Event} Event\n */ // Port of `edit_map.rs` from `markdown-rs`.\n// This should move to `markdown-js` later.\n// Deal with several changes in events, batching them together.\n//\n// Preferably, changes should be kept to a minimum.\n// Sometimes, it’s needed to change the list of events, because parsing can be\n// messy, and it helps to expose a cleaner interface of events to the compiler\n// and other users.\n// It can also help to merge many adjacent similar events.\n// And, in other cases, it’s needed to parse subcontent: pass some events\n// through another tokenizer and inject the result.\n/**\n * @typedef {[number, number, Array<Event>]} Change\n * @typedef {[number, number, number]} Jump\n */ /**\n * Tracks a bunch of edits.\n */ class EditMap {\n    /**\n   * Create a new edit map.\n   */ constructor(){\n        /**\n     * Record of changes.\n     *\n     * @type {Array<Change>}\n     */ this.map = [];\n    }\n    /**\n   * Create an edit: a remove and/or add at a certain place.\n   *\n   * @param {number} index\n   * @param {number} remove\n   * @param {Array<Event>} add\n   * @returns {void}\n   */ add(index, remove, add) {\n        addImpl(this, index, remove, add);\n    }\n    // To do: not used here.\n    // /**\n    //  * Create an edit: but insert `add` before existing additions.\n    //  *\n    //  * @param {number} index\n    //  * @param {number} remove\n    //  * @param {Array<Event>} add\n    //  * @returns {void}\n    //  */\n    // addBefore(index, remove, add) {\n    //   addImpl(this, index, remove, add, true)\n    // }\n    /**\n   * Done, change the events.\n   *\n   * @param {Array<Event>} events\n   * @returns {void}\n   */ consume(events) {\n        this.map.sort((a, b)=>a[0] - b[0]);\n        /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */ if (this.map.length === 0) {\n            return;\n        }\n        // To do: if links are added in events, like they are in `markdown-rs`,\n        // this is needed.\n        // // Calculate jumps: where items in the current list move to.\n        // /** @type {Array<Jump>} */\n        // const jumps = []\n        // let index = 0\n        // let addAcc = 0\n        // let removeAcc = 0\n        // while (index < this.map.length) {\n        //   const [at, remove, add] = this.map[index]\n        //   removeAcc += remove\n        //   addAcc += add.length\n        //   jumps.push([at, removeAcc, addAcc])\n        //   index += 1\n        // }\n        //\n        // . shiftLinks(events, jumps)\n        let index = this.map.length;\n        /** @type {Array<Array<Event>>} */ const vecs = [];\n        while(index > 0){\n            index -= 1;\n            vecs.push(events.slice(this.map[index][0] + this.map[index][1]));\n            // eslint-disable-next-line unicorn/no-array-push-push\n            vecs.push(this.map[index][2]);\n            // Truncate rest.\n            events.length = this.map[index][0];\n        }\n        vecs.push([\n            ...events\n        ]);\n        events.length = 0;\n        let slice = vecs.pop();\n        while(slice){\n            events.push(...slice);\n            slice = vecs.pop();\n        }\n        // Truncate everything.\n        this.map.length = 0;\n    }\n}\n/**\n * Create an edit.\n *\n * @param {EditMap} editMap\n * @param {number} at\n * @param {number} remove\n * @param {Array<Event>} add\n * @returns {void}\n */ function addImpl(editMap, at, remove, add) {\n    let index = 0;\n    /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */ if (remove === 0 && add.length === 0) {\n        return;\n    }\n    while(index < editMap.map.length){\n        if (editMap.map[index][0] === at) {\n            editMap.map[index][1] += remove;\n            // To do: before not used.\n            // if (before) {\n            //   add.push(...editMap.map[index][2])\n            //   editMap.map[index][2] = add\n            // } else {\n            editMap.map[index][2].push(...add);\n            // }\n            return;\n        }\n        index += 1;\n    }\n    editMap.map.push([\n        at,\n        remove,\n        add\n    ]);\n} // /**\n //  * Shift `previous` and `next` links according to `jumps`.\n //  *\n //  * This fixes links in case there are events removed or added between them.\n //  *\n //  * @param {Array<Event>} events\n //  * @param {Array<Jump>} jumps\n //  */\n // function shiftLinks(events, jumps) {\n //   let jumpIndex = 0\n //   let index = 0\n //   let add = 0\n //   let rm = 0\n //   while (index < events.length) {\n //     const rmCurr = rm\n //     while (jumpIndex < jumps.length && jumps[jumpIndex][0] <= index) {\n //       add = jumps[jumpIndex][2]\n //       rm = jumps[jumpIndex][1]\n //       jumpIndex += 1\n //     }\n //     // Ignore items that will be removed.\n //     if (rm > rmCurr) {\n //       index += rm - rmCurr\n //     } else {\n //       console.log('to do: links?', add, rmCurr)\n //       // ?\n //       // if let Some(link) = &events[index].link {\n //       //     if let Some(next) = link.next {\n //       //         events[next].link.as_mut().unwrap().previous = Some(index + add - rm);\n //       //         while jumpIndex < jumps.len() && jumps[jumpIndex].0 <= next {\n //       //             add = jumps[jumpIndex].2;\n //       //             rm = jumps[jumpIndex].1;\n //       //             jumpIndex += 1;\n //       //         }\n //       //         events[index].link.as_mut().unwrap().next = Some(next + add - rm);\n //       //         index = next;\n //       //         continue;\n //       //     }\n //       // }\n //       index += 1\n //     }\n //   }\n // }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFibGUvZGV2L2xpYi9lZGl0LW1hcC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0NBRUMsR0FFRCw0Q0FBNEM7QUFDNUMsMkNBQTJDO0FBRTNDLCtEQUErRDtBQUMvRCxFQUFFO0FBQ0YsbURBQW1EO0FBQ25ELDhFQUE4RTtBQUM5RSw4RUFBOEU7QUFDOUUsbUJBQW1CO0FBQ25CLDBEQUEwRDtBQUMxRCx5RUFBeUU7QUFDekUsbURBQW1EO0FBRW5EOzs7Q0FHQyxHQUVEOztDQUVDLEdBQ00sTUFBTUE7SUFDWDs7R0FFQyxHQUNEQyxhQUFjO1FBQ1o7Ozs7S0FJQyxHQUNELElBQUksQ0FBQ0MsR0FBRyxHQUFHLEVBQUU7SUFDZjtJQUVBOzs7Ozs7O0dBT0MsR0FDREMsSUFBSUMsS0FBSyxFQUFFQyxNQUFNLEVBQUVGLEdBQUcsRUFBRTtRQUN0QkcsUUFBUSxJQUFJLEVBQUVGLE9BQU9DLFFBQVFGO0lBQy9CO0lBRUEsd0JBQXdCO0lBQ3hCLE1BQU07SUFDTixpRUFBaUU7SUFDakUsS0FBSztJQUNMLDJCQUEyQjtJQUMzQiw0QkFBNEI7SUFDNUIsK0JBQStCO0lBQy9CLHFCQUFxQjtJQUNyQixNQUFNO0lBQ04sa0NBQWtDO0lBQ2xDLDRDQUE0QztJQUM1QyxJQUFJO0lBRUo7Ozs7O0dBS0MsR0FDREksUUFBUUMsTUFBTSxFQUFFO1FBQ2QsSUFBSSxDQUFDTixHQUFHLENBQUNPLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxDQUFDLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRTtRQUVuQyxtRkFBbUYsR0FDbkYsSUFBSSxJQUFJLENBQUNULEdBQUcsQ0FBQ1UsTUFBTSxLQUFLLEdBQUc7WUFDekI7UUFDRjtRQUVBLHVFQUF1RTtRQUN2RSxrQkFBa0I7UUFDbEIsK0RBQStEO1FBQy9ELDZCQUE2QjtRQUM3QixtQkFBbUI7UUFDbkIsZ0JBQWdCO1FBQ2hCLGlCQUFpQjtR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dGtpdCwgbmV4dC5qcywgYW5kIG9wZW5haSBncHQ0Ly4vbm9kZV9tb2R1bGVzL21pY3JvbWFyay1leHRlbnNpb24tZ2ZtLXRhYmxlL2Rldi9saWIvZWRpdC1tYXAuanM/MDRlNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRXZlbnR9IEV2ZW50XG4gKi9cblxuLy8gUG9ydCBvZiBgZWRpdF9tYXAucnNgIGZyb20gYG1hcmtkb3duLXJzYC5cbi8vIFRoaXMgc2hvdWxkIG1vdmUgdG8gYG1hcmtkb3duLWpzYCBsYXRlci5cblxuLy8gRGVhbCB3aXRoIHNldmVyYWwgY2hhbmdlcyBpbiBldmVudHMsIGJhdGNoaW5nIHRoZW0gdG9nZXRoZXIuXG4vL1xuLy8gUHJlZmVyYWJseSwgY2hhbmdlcyBzaG91bGQgYmUga2VwdCB0byBhIG1pbmltdW0uXG4vLyBTb21ldGltZXMsIGl04oCZcyBuZWVkZWQgdG8gY2hhbmdlIHRoZSBsaXN0IG9mIGV2ZW50cywgYmVjYXVzZSBwYXJzaW5nIGNhbiBiZVxuLy8gbWVzc3ksIGFuZCBpdCBoZWxwcyB0byBleHBvc2UgYSBjbGVhbmVyIGludGVyZmFjZSBvZiBldmVudHMgdG8gdGhlIGNvbXBpbGVyXG4vLyBhbmQgb3RoZXIgdXNlcnMuXG4vLyBJdCBjYW4gYWxzbyBoZWxwIHRvIG1lcmdlIG1hbnkgYWRqYWNlbnQgc2ltaWxhciBldmVudHMuXG4vLyBBbmQsIGluIG90aGVyIGNhc2VzLCBpdOKAmXMgbmVlZGVkIHRvIHBhcnNlIHN1YmNvbnRlbnQ6IHBhc3Mgc29tZSBldmVudHNcbi8vIHRocm91Z2ggYW5vdGhlciB0b2tlbml6ZXIgYW5kIGluamVjdCB0aGUgcmVzdWx0LlxuXG4vKipcbiAqIEB0eXBlZGVmIHtbbnVtYmVyLCBudW1iZXIsIEFycmF5PEV2ZW50Pl19IENoYW5nZVxuICogQHR5cGVkZWYge1tudW1iZXIsIG51bWJlciwgbnVtYmVyXX0gSnVtcFxuICovXG5cbi8qKlxuICogVHJhY2tzIGEgYnVuY2ggb2YgZWRpdHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBFZGl0TWFwIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBlZGl0IG1hcC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKlxuICAgICAqIFJlY29yZCBvZiBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogQHR5cGUge0FycmF5PENoYW5nZT59XG4gICAgICovXG4gICAgdGhpcy5tYXAgPSBbXVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBlZGl0OiBhIHJlbW92ZSBhbmQvb3IgYWRkIGF0IGEgY2VydGFpbiBwbGFjZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZW1vdmVcbiAgICogQHBhcmFtIHtBcnJheTxFdmVudD59IGFkZFxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGFkZChpbmRleCwgcmVtb3ZlLCBhZGQpIHtcbiAgICBhZGRJbXBsKHRoaXMsIGluZGV4LCByZW1vdmUsIGFkZClcbiAgfVxuXG4gIC8vIFRvIGRvOiBub3QgdXNlZCBoZXJlLlxuICAvLyAvKipcbiAgLy8gICogQ3JlYXRlIGFuIGVkaXQ6IGJ1dCBpbnNlcnQgYGFkZGAgYmVmb3JlIGV4aXN0aW5nIGFkZGl0aW9ucy5cbiAgLy8gICpcbiAgLy8gICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gIC8vICAqIEBwYXJhbSB7bnVtYmVyfSByZW1vdmVcbiAgLy8gICogQHBhcmFtIHtBcnJheTxFdmVudD59IGFkZFxuICAvLyAgKiBAcmV0dXJucyB7dm9pZH1cbiAgLy8gICovXG4gIC8vIGFkZEJlZm9yZShpbmRleCwgcmVtb3ZlLCBhZGQpIHtcbiAgLy8gICBhZGRJbXBsKHRoaXMsIGluZGV4LCByZW1vdmUsIGFkZCwgdHJ1ZSlcbiAgLy8gfVxuXG4gIC8qKlxuICAgKiBEb25lLCBjaGFuZ2UgdGhlIGV2ZW50cy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxFdmVudD59IGV2ZW50c1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGNvbnN1bWUoZXZlbnRzKSB7XG4gICAgdGhpcy5tYXAuc29ydCgoYSwgYikgPT4gYVswXSAtIGJbMF0pXG5cbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAzIC0tIGByZXNvbHZlYCBpcyBuZXZlciBjYWxsZWQgd2l0aG91dCB0YWJsZXMsIHNvIHdpdGhvdXQgZWRpdHMuICovXG4gICAgaWYgKHRoaXMubWFwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gVG8gZG86IGlmIGxpbmtzIGFyZSBhZGRlZCBpbiBldmVudHMsIGxpa2UgdGhleSBhcmUgaW4gYG1hcmtkb3duLXJzYCxcbiAgICAvLyB0aGlzIGlzIG5lZWRlZC5cbiAgICAvLyAvLyBDYWxjdWxhdGUganVtcHM6IHdoZXJlIGl0ZW1zIGluIHRoZSBjdXJyZW50IGxpc3QgbW92ZSB0by5cbiAgICAvLyAvKiogQHR5cGUge0FycmF5PEp1bXA+fSAqL1xuICAgIC8vIGNvbnN0IGp1bXBzID0gW11cbiAgICAvLyBsZXQgaW5kZXggPSAwXG4gICAgLy8gbGV0IGFkZEFjYyA9IDBcbiAgICAvLyBsZXQgcmVtb3ZlQWNjID0gMFxuICAgIC8vIHdoaWxlIChpbmRleCA8IHRoaXMubWFwLmxlbmd0aCkge1xuICAgIC8vICAgY29uc3QgW2F0LCByZW1vdmUsIGFkZF0gPSB0aGlzLm1hcFtpbmRleF1cbiAgICAvLyAgIHJlbW92ZUFjYyArPSByZW1vdmVcbiAgICAvLyAgIGFkZEFjYyArPSBhZGQubGVuZ3RoXG4gICAgLy8gICBqdW1wcy5wdXNoKFthdCwgcmVtb3ZlQWNjLCBhZGRBY2NdKVxuICAgIC8vICAgaW5kZXggKz0gMVxuICAgIC8vIH1cbiAgICAvL1xuICAgIC8vIC4gc2hpZnRMaW5rcyhldmVudHMsIGp1bXBzKVxuXG4gICAgbGV0IGluZGV4ID0gdGhpcy5tYXAubGVuZ3RoXG4gICAgLyoqIEB0eXBlIHtBcnJheTxBcnJheTxFdmVudD4+fSAqL1xuICAgIGNvbnN0IHZlY3MgPSBbXVxuICAgIHdoaWxlIChpbmRleCA+IDApIHtcbiAgICAgIGluZGV4IC09IDFcbiAgICAgIHZlY3MucHVzaChldmVudHMuc2xpY2UodGhpcy5tYXBbaW5kZXhdWzBdICsgdGhpcy5tYXBbaW5kZXhdWzFdKSlcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL25vLWFycmF5LXB1c2gtcHVzaFxuICAgICAgdmVjcy5wdXNoKHRoaXMubWFwW2luZGV4XVsyXSlcblxuICAgICAgLy8gVHJ1bmNhdGUgcmVzdC5cbiAgICAgIGV2ZW50cy5sZW5ndGggPSB0aGlzLm1hcFtpbmRleF1bMF1cbiAgICB9XG5cbiAgICB2ZWNzLnB1c2goWy4uLmV2ZW50c10pXG4gICAgZXZlbnRzLmxlbmd0aCA9IDBcblxuICAgIGxldCBzbGljZSA9IHZlY3MucG9wKClcblxuICAgIHdoaWxlIChzbGljZSkge1xuICAgICAgZXZlbnRzLnB1c2goLi4uc2xpY2UpXG4gICAgICBzbGljZSA9IHZlY3MucG9wKClcbiAgICB9XG5cbiAgICAvLyBUcnVuY2F0ZSBldmVyeXRoaW5nLlxuICAgIHRoaXMubWFwLmxlbmd0aCA9IDBcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBlZGl0LlxuICpcbiAqIEBwYXJhbSB7RWRpdE1hcH0gZWRpdE1hcFxuICogQHBhcmFtIHtudW1iZXJ9IGF0XG4gKiBAcGFyYW0ge251bWJlcn0gcmVtb3ZlXG4gKiBAcGFyYW0ge0FycmF5PEV2ZW50Pn0gYWRkXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gYWRkSW1wbChlZGl0TWFwLCBhdCwgcmVtb3ZlLCBhZGQpIHtcbiAgbGV0IGluZGV4ID0gMFxuXG4gIC8qIGM4IGlnbm9yZSBuZXh0IDMgLS0gYHJlc29sdmVgIGlzIG5ldmVyIGNhbGxlZCB3aXRob3V0IHRhYmxlcywgc28gd2l0aG91dCBlZGl0cy4gKi9cbiAgaWYgKHJlbW92ZSA9PT0gMCAmJiBhZGQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB3aGlsZSAoaW5kZXggPCBlZGl0TWFwLm1hcC5sZW5ndGgpIHtcbiAgICBpZiAoZWRpdE1hcC5tYXBbaW5kZXhdWzBdID09PSBhdCkge1xuICAgICAgZWRpdE1hcC5tYXBbaW5kZXhdWzFdICs9IHJlbW92ZVxuXG4gICAgICAvLyBUbyBkbzogYmVmb3JlIG5vdCB1c2VkLlxuICAgICAgLy8gaWYgKGJlZm9yZSkge1xuICAgICAgLy8gICBhZGQucHVzaCguLi5lZGl0TWFwLm1hcFtpbmRleF1bMl0pXG4gICAgICAvLyAgIGVkaXRNYXAubWFwW2luZGV4XVsyXSA9IGFkZFxuICAgICAgLy8gfSBlbHNlIHtcbiAgICAgIGVkaXRNYXAubWFwW2luZGV4XVsyXS5wdXNoKC4uLmFkZClcbiAgICAgIC8vIH1cblxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaW5kZXggKz0gMVxuICB9XG5cbiAgZWRpdE1hcC5tYXAucHVzaChbYXQsIHJlbW92ZSwgYWRkXSlcbn1cblxuLy8gLyoqXG4vLyAgKiBTaGlmdCBgcHJldmlvdXNgIGFuZCBgbmV4dGAgbGlua3MgYWNjb3JkaW5nIHRvIGBqdW1wc2AuXG4vLyAgKlxuLy8gICogVGhpcyBmaXhlcyBsaW5rcyBpbiBjYXNlIHRoZXJlIGFyZSBldmVudHMgcmVtb3ZlZCBvciBhZGRlZCBiZXR3ZWVuIHRoZW0uXG4vLyAgKlxuLy8gICogQHBhcmFtIHtBcnJheTxFdmVudD59IGV2ZW50c1xuLy8gICogQHBhcmFtIHtBcnJheTxKdW1wPn0ganVtcHNcbi8vICAqL1xuLy8gZnVuY3Rpb24gc2hpZnRMaW5rcyhldmVudHMsIGp1bXBzKSB7XG4vLyAgIGxldCBqdW1wSW5kZXggPSAwXG4vLyAgIGxldCBpbmRleCA9IDBcbi8vICAgbGV0IGFkZCA9IDBcbi8vICAgbGV0IHJtID0gMFxuXG4vLyAgIHdoaWxlIChpbmRleCA8IGV2ZW50cy5sZW5ndGgpIHtcbi8vICAgICBjb25zdCBybUN1cnIgPSBybVxuXG4vLyAgICAgd2hpbGUgKGp1bXBJbmRleCA8IGp1bXBzLmxlbmd0aCAmJiBqdW1wc1tqdW1wSW5kZXhdWzBdIDw9IGluZGV4KSB7XG4vLyAgICAgICBhZGQgPSBqdW1wc1tqdW1wSW5kZXhdWzJdXG4vLyAgICAgICBybSA9IGp1bXBzW2p1bXBJbmRleF1bMV1cbi8vICAgICAgIGp1bXBJbmRleCArPSAxXG4vLyAgICAgfVxuXG4vLyAgICAgLy8gSWdub3JlIGl0ZW1zIHRoYXQgd2lsbCBiZSByZW1vdmVkLlxuLy8gICAgIGlmIChybSA+IHJtQ3Vycikge1xuLy8gICAgICAgaW5kZXggKz0gcm0gLSBybUN1cnJcbi8vICAgICB9IGVsc2Uge1xuLy8gICAgICAgY29uc29sZS5sb2coJ3RvIGRvOiBsaW5rcz8nLCBhZGQsIHJtQ3Vycilcbi8vICAgICAgIC8vID9cbi8vICAgICAgIC8vIGlmIGxldCBTb21lKGxpbmspID0gJmV2ZW50c1tpbmRleF0ubGluayB7XG4vLyAgICAgICAvLyAgICAgaWYgbGV0IFNvbWUobmV4dCkgPSBsaW5rLm5leHQge1xuLy8gICAgICAgLy8gICAgICAgICBldmVudHNbbmV4dF0ubGluay5hc19tdXQoKS51bndyYXAoKS5wcmV2aW91cyA9IFNvbWUoaW5kZXggKyBhZGQgLSBybSk7XG4vLyAgICAgICAvLyAgICAgICAgIHdoaWxlIGp1bXBJbmRleCA8IGp1bXBzLmxlbigpICYmIGp1bXBzW2p1bXBJbmRleF0uMCA8PSBuZXh0IHtcbi8vICAgICAgIC8vICAgICAgICAgICAgIGFkZCA9IGp1bXBzW2p1bXBJbmRleF0uMjtcbi8vICAgICAgIC8vICAgICAgICAgICAgIHJtID0ganVtcHNbanVtcEluZGV4XS4xO1xuLy8gICAgICAgLy8gICAgICAgICAgICAganVtcEluZGV4ICs9IDE7XG4vLyAgICAgICAvLyAgICAgICAgIH1cbi8vICAgICAgIC8vICAgICAgICAgZXZlbnRzW2luZGV4XS5saW5rLmFzX211dCgpLnVud3JhcCgpLm5leHQgPSBTb21lKG5leHQgKyBhZGQgLSBybSk7XG4vLyAgICAgICAvLyAgICAgICAgIGluZGV4ID0gbmV4dDtcbi8vICAgICAgIC8vICAgICAgICAgY29udGludWU7XG4vLyAgICAgICAvLyAgICAgfVxuLy8gICAgICAgLy8gfVxuLy8gICAgICAgaW5kZXggKz0gMVxuLy8gICAgIH1cbi8vICAgfVxuLy8gfVxuIl0sIm5hbWVzIjpbIkVkaXRNYXAiLCJjb25zdHJ1Y3RvciIsIm1hcCIsImFkZCIsImluZGV4IiwicmVtb3ZlIiwiYWRkSW1wbCIsImNvbnN1bWUiLCJldmVudHMiLCJzb3J0IiwiYSIsImIiLCJsZW5ndGgiLCJ2ZWNzIiwicHVzaCIsInNsaWNlIiwicG9wIiwiZWRpdE1hcCIsImF0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/micromark-extension-gfm-table/dev/lib/edit-map.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/micromark-extension-gfm-table/dev/lib/html.js":
/*!********************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-table/dev/lib/html.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmTableHtml: () => (/* binding */ gfmTableHtml)\n/* harmony export */ });\n/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uvu/assert */ \"(ssr)/./node_modules/uvu/assert/index.mjs\");\n/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */ /**\n * @typedef {import('./infer.js').Align} Align\n */ \nconst alignment = {\n    none: \"\",\n    left: ' align=\"left\"',\n    right: ' align=\"right\"',\n    center: ' align=\"center\"'\n};\n// To do: next major: expose functions.\n// To do: next major: use `infer` here, when all events are exposed.\n/**\n * Extension for `micromark` that can be passed in `htmlExtensions` to support\n * GFM tables when serializing to HTML.\n *\n * @type {HtmlExtension}\n */ const gfmTableHtml = {\n    enter: {\n        table (token) {\n            const tableAlign = token._align;\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tableAlign, \"expected `_align`\");\n            this.lineEndingIfNeeded();\n            this.tag(\"<table>\");\n            this.setData(\"tableAlign\", tableAlign);\n        },\n        tableBody () {\n            this.tag(\"<tbody>\");\n        },\n        tableData () {\n            const tableAlign = this.getData(\"tableAlign\");\n            const tableColumn = this.getData(\"tableColumn\");\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tableAlign, \"expected `tableAlign`\");\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(typeof tableColumn === \"number\", \"expected `tableColumn`\");\n            const align = alignment[tableAlign[tableColumn]];\n            if (align === undefined) {\n                // Capture results to ignore them.\n                this.buffer();\n            } else {\n                this.lineEndingIfNeeded();\n                this.tag(\"<td\" + align + \">\");\n            }\n        },\n        tableHead () {\n            this.lineEndingIfNeeded();\n            this.tag(\"<thead>\");\n        },\n        tableHeader () {\n            const tableAlign = this.getData(\"tableAlign\");\n            const tableColumn = this.getData(\"tableColumn\");\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tableAlign, \"expected `tableAlign`\");\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(typeof tableColumn === \"number\", \"expected `tableColumn`\");\n            const align = alignment[tableAlign[tableColumn]];\n            this.lineEndingIfNeeded();\n            this.tag(\"<th\" + align + \">\");\n        },\n        tableRow () {\n            this.setData(\"tableColumn\", 0);\n            this.lineEndingIfNeeded();\n            this.tag(\"<tr>\");\n        }\n    },\n    exit: {\n        // Overwrite the default code text data handler to unescape escaped pipes when\n        // they are in tables.\n        codeTextData (token) {\n            let value = this.sliceSerialize(token);\n            if (this.getData(\"tableAlign\")) {\n                value = value.replace(/\\\\([\\\\|])/g, replace);\n            }\n            this.raw(this.encode(value));\n        },\n        table () {\n            this.setData(\"tableAlign\");\n            // Note: we don’t set `slurpAllLineEndings` anymore, in delimiter rows,\n            // but we do need to reset it to match a funky newline GH generates for\n            // list items combined with tables.\n            this.setData(\"slurpAllLineEndings\");\n            this.lineEndingIfNeeded();\n            this.tag(\"</table>\");\n        },\n        tableBody () {\n            this.lineEndingIfNeeded();\n            this.tag(\"</tbody>\");\n        },\n        tableData () {\n            const tableAlign = this.getData(\"tableAlign\");\n            const tableColumn = this.getData(\"tableColumn\");\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tableAlign, \"expected `tableAlign`\");\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(typeof tableColumn === \"number\", \"expected `tableColumn`\");\n            if (tableColumn in tableAlign) {\n                this.tag(\"</td>\");\n                this.setData(\"tableColumn\", tableColumn + 1);\n            } else {\n                // Stop capturing.\n                this.resume();\n            }\n        },\n        tableHead () {\n            this.lineEndingIfNeeded();\n            this.tag(\"</thead>\");\n        },\n        tableHeader () {\n            const tableColumn = this.getData(\"tableColumn\");\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(typeof tableColumn === \"number\", \"expected `tableColumn`\");\n            this.tag(\"</th>\");\n            this.setData(\"tableColumn\", tableColumn + 1);\n        },\n        tableRow () {\n            const tableAlign = this.getData(\"tableAlign\");\n            let tableColumn = this.getData(\"tableColumn\");\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(tableAlign, \"expected `tableAlign`\");\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(typeof tableColumn === \"number\", \"expected `tableColumn`\");\n            while(tableColumn < tableAlign.length){\n                this.lineEndingIfNeeded();\n                this.tag(\"<td\" + alignment[tableAlign[tableColumn]] + \"></td>\");\n                tableColumn++;\n            }\n            this.setData(\"tableColumn\", tableColumn);\n            this.lineEndingIfNeeded();\n            this.tag(\"</tr>\");\n        }\n    }\n};\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */ function replace($0, $1) {\n    // Pipes work, backslashes don’t (but can’t escape pipes).\n    return $1 === \"|\" ? $1 : $0;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFibGUvZGV2L2xpYi9odG1sLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7O0NBRUMsR0FFRDs7Q0FFQyxHQUVzQztBQUV2QyxNQUFNRSxZQUFZO0lBQ2hCQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTztJQUNQQyxRQUFRO0FBQ1Y7QUFFQSx1Q0FBdUM7QUFDdkMsb0VBQW9FO0FBRXBFOzs7OztDQUtDLEdBQ00sTUFBTUMsZUFBZTtJQUMxQkMsT0FBTztRQUNMQyxPQUFNQyxLQUFLO1lBQ1QsTUFBTUMsYUFBYUQsTUFBTUUsTUFBTTtZQUMvQlgsOENBQU1BLENBQUNVLFlBQVk7WUFDbkIsSUFBSSxDQUFDRSxrQkFBa0I7WUFDdkIsSUFBSSxDQUFDQyxHQUFHLENBQUM7WUFDVCxJQUFJLENBQUNDLE9BQU8sQ0FBQyxjQUFjSjtRQUM3QjtRQUNBSztZQUNFLElBQUksQ0FBQ0YsR0FBRyxDQUFDO1FBQ1g7UUFDQUc7WUFDRSxNQUFNTixhQUFhLElBQUksQ0FBQ08sT0FBTyxDQUFDO1lBQ2hDLE1BQU1DLGNBQWMsSUFBSSxDQUFDRCxPQUFPLENBQUM7WUFDakNqQiw4Q0FBTUEsQ0FBQ1UsWUFBWTtZQUNuQlYsOENBQU1BLENBQUMsT0FBT2tCLGdCQUFnQixVQUFVO1lBQ3hDLE1BQU1DLFFBQVFsQixTQUFTLENBQUNTLFVBQVUsQ0FBQ1EsWUFBWSxDQUFDO1lBRWhELElBQUlDLFVBQVVDLFdBQVc7Z0JBQ3ZCLGtDQUFrQztnQkFDbEMsSUFBSSxDQUFDQyxNQUFNO1lBQ2IsT0FBTztnQkFDTCxJQUFJLENBQUNULGtCQUFrQjtnQkFDdkIsSUFBSSxDQUFDQyxHQUFHLENBQUMsUUFBUU0sUUFBUTtZQUMzQjtRQUNGO1FBQ0FHO1lBQ0UsSUFBSSxDQUFDVixrQkFBa0I7WUFDdkIsSUFBSSxDQUFDQyxHQUFHLENBQUM7UUFDWDtRQUNBVTtZQUNFLE1BQU1iLGFBQWEsSUFBSSxDQUFDTyxPQUFPLENBQUM7WUFDaEMsTUFBTUMsY0FBYyxJQUFJLENBQUNELE9BQU8sQ0FBQztZQUNqQ2pCLDhDQUFNQSxDQUFDVSxZQUFZO1lBQ25CViw4Q0FBTUEsQ0FBQyxPQUFPa0IsZ0JBQWdCLFVBQVU7WUFDeEMsTUFBTUMsUUFBUWxCLFNBQVMsQ0FBQ1MsVUFBVSxDQUFDUSxZQUFZLENBQUM7WUFDaEQsSUFBSSxDQUFDTixrQkFBa0I7WUFDdkIsSUFBSSxDQUFDQyxHQUFHLENBQUMsUUFBUU0sUUFBUTtRQUMzQjtRQUNBSztZQUNFLElBQUksQ0FBQ1YsT0FBTyxDQUFDLGVBQWU7WUFDNUIsSUFBSSxDQUFDRixrQkFBa0I7WUFDdkIsSUFBSSxDQUFDQyxHQUFHLENBQUM7UUFDWDtJQUNGO0lBQ0FZLE1BQU07UUFDSiw4RUFBOEU7UUFDOUUsc0JBQXNCO1FBQ3RCQyxjQUFhakIsS0FBSztZQUNoQixJQUFJa0IsUUFBUSxJQUFJLENBQUNDLGNBQWMsQ0FBQ25CO1lBRWhDLElBQUksSUFBSSxDQUFDUSxPQUFPLENBQUMsZUFBZTtnQkFDOUJVLFFBQVFBLE1BQU1FLE9BQU8sQ0FBQyxjQUFjQTtZQUN0QztZQUVBLElBQUksQ0FBQ0MsR0FBRyxDQUFDLElBQUksQ0FBQ0MsTUFBTSxDQUFDSjtRQUN2QjtRQUNBbkI7WUFDRSxJQUFJLENBQUNNLE9BQU8sQ0FBQztZQUNiLHVFQUF1RTtZQUN2RSx1RUFBdUU7WUFDdkUsbUNBQW1DO1lBQ25DLElBQUksQ0FBQ0EsT0FBTyxDQUFDO1lBQ2IsSUFBSSxDQUFDRixrQkFBa0I7WUFDdkIsSUFBSSxDQUFDQyxHQUFHLENBQUM7UUFDWDtRQUNBRTtZQUNFLElBQUksQ0FBQ0gsa0JBQWtCO1lBQ3ZCLElBQUksQ0FBQ0MsR0FBRyxDQUFDO1FBQ1g7UUFDQUc7WUFDRSxNQUFNTixhQUFhLElBQUksQ0FBQ08sT0FBTyxDQUFDO1lBQ2hDLE1BQU1DLGNBQWMsSUFBSSxDQUFDRCxPQUFPLENBQUM7WUFDakNqQiw4Q0FBTUEsQ0FBQ1UsWUFBWTtZQUNuQlYsOENBQU1BLENBQUMsT0FBT2tCLGdCQUFnQixVQUFVO1lBRXhDLElBQUlBLGVBQWVSLFlBQVk7Z0JBQzdCLElBQUksQ0FBQ0csR0FBRyxDQUFDO2dCQUNULElBQUksQ0FBQ0MsT0FBTyxDQUFDLGVBQWVJLGNBQWM7WUFDNUMsT0FBTztnQkFDTCxrQkFBa0I7Z0JBQ2xCLElBQUksQ0FBQ2MsTUFBTTtZQUNiO1FBQ0Y7UUFDQVY7WUFDRSxJQUFJLENBQUNWLGtCQUFrQjtZQUN2QixJQUFJLENBQUNDLEdBQUcsQ0FBQztRQUNYO1FBQ0FVO1lBQ0UsTUFBTUwsY0FBYyxJQUFJLENBQUNELE9BQU8sQ0FBQztZQUNqQ2pCLDhDQUFNQSxDQUFDLE9BQU9rQixnQkFBZ0IsVUFBVTtZQUN4QyxJQUFJLENBQUNMLEdBQUcsQ0FBQztZQUNULElBQUksQ0FBQ0MsT0FBTyxDQUFDLGVBQWVJLGNBQWM7UUFDNUM7UUFDQU07WUFDRSxNQUFNZCxhQUFhLElBQUksQ0FBQ08sT0FBTyxDQUFDO1lBQ2hDLElBQUlDLGNBQWMsSUFBSSxDQUFDRCxPQUFPLENBQUM7WUFDL0JqQiw4Q0FBTUEsQ0FBQ1UsWUFBWTtZQUNuQlYsOENBQU1BLENBQUMsT0FBT2tCLGdCQUFnQixVQUFVO1lBRXhDLE1BQU9BLGNBQWNSLFdBQVd1QixNQUFNLENBQUU7Z0JBQ3RDLElBQUksQ0FBQ3JCLGtCQUFrQjtnQkFDdkIsSUFBSSxDQUFDQyxHQUFHLENBQUMsUUFBUVosU0FBUyxDQUFDUyxVQUFVLENBQUNRLFlBQVksQ0FBQyxHQUFHO2dCQUN0REE7WUFDRjtZQUVBLElBQUksQ0FBQ0osT0FBTyxDQUFDLGVBQWVJO1lBQzVCLElBQUksQ0FBQ04sa0JBQWtCO1lBQ3ZCLElBQUksQ0FBQ0MsR0FBRyxDQUFDO1FBQ1g7SUFDRjtBQUNGLEVBQUM7QUFFRDs7OztDQUlDLEdBQ0QsU0FBU2dCLFFBQVFLLEVBQUUsRUFBRUMsRUFBRTtJQUNyQiwwREFBMEQ7SUFDMUQsT0FBT0EsT0FBTyxNQUFNQSxLQUFLRDtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL3YwIGNsb25lIHdpdGggY29waWxvdGtpdCwgbmV4dC5qcywgYW5kIG9wZW5haSBncHQ0Ly4vbm9kZV9tb2R1bGVzL21pY3JvbWFyay1leHRlbnNpb24tZ2ZtLXRhYmxlL2Rldi9saWIvaHRtbC5qcz9lYTZlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5IdG1sRXh0ZW5zaW9ufSBIdG1sRXh0ZW5zaW9uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2luZmVyLmpzJykuQWxpZ259IEFsaWduXG4gKi9cblxuaW1wb3J0IHtvayBhcyBhc3NlcnR9IGZyb20gJ3V2dS9hc3NlcnQnXG5cbmNvbnN0IGFsaWdubWVudCA9IHtcbiAgbm9uZTogJycsXG4gIGxlZnQ6ICcgYWxpZ249XCJsZWZ0XCInLFxuICByaWdodDogJyBhbGlnbj1cInJpZ2h0XCInLFxuICBjZW50ZXI6ICcgYWxpZ249XCJjZW50ZXJcIidcbn1cblxuLy8gVG8gZG86IG5leHQgbWFqb3I6IGV4cG9zZSBmdW5jdGlvbnMuXG4vLyBUbyBkbzogbmV4dCBtYWpvcjogdXNlIGBpbmZlcmAgaGVyZSwgd2hlbiBhbGwgZXZlbnRzIGFyZSBleHBvc2VkLlxuXG4vKipcbiAqIEV4dGVuc2lvbiBmb3IgYG1pY3JvbWFya2AgdGhhdCBjYW4gYmUgcGFzc2VkIGluIGBodG1sRXh0ZW5zaW9uc2AgdG8gc3VwcG9ydFxuICogR0ZNIHRhYmxlcyB3aGVuIHNlcmlhbGl6aW5nIHRvIEhUTUwuXG4gKlxuICogQHR5cGUge0h0bWxFeHRlbnNpb259XG4gKi9cbmV4cG9ydCBjb25zdCBnZm1UYWJsZUh0bWwgPSB7XG4gIGVudGVyOiB7XG4gICAgdGFibGUodG9rZW4pIHtcbiAgICAgIGNvbnN0IHRhYmxlQWxpZ24gPSB0b2tlbi5fYWxpZ25cbiAgICAgIGFzc2VydCh0YWJsZUFsaWduLCAnZXhwZWN0ZWQgYF9hbGlnbmAnKVxuICAgICAgdGhpcy5saW5lRW5kaW5nSWZOZWVkZWQoKVxuICAgICAgdGhpcy50YWcoJzx0YWJsZT4nKVxuICAgICAgdGhpcy5zZXREYXRhKCd0YWJsZUFsaWduJywgdGFibGVBbGlnbilcbiAgICB9LFxuICAgIHRhYmxlQm9keSgpIHtcbiAgICAgIHRoaXMudGFnKCc8dGJvZHk+JylcbiAgICB9LFxuICAgIHRhYmxlRGF0YSgpIHtcbiAgICAgIGNvbnN0IHRhYmxlQWxpZ24gPSB0aGlzLmdldERhdGEoJ3RhYmxlQWxpZ24nKVxuICAgICAgY29uc3QgdGFibGVDb2x1bW4gPSB0aGlzLmdldERhdGEoJ3RhYmxlQ29sdW1uJylcbiAgICAgIGFzc2VydCh0YWJsZUFsaWduLCAnZXhwZWN0ZWQgYHRhYmxlQWxpZ25gJylcbiAgICAgIGFzc2VydCh0eXBlb2YgdGFibGVDb2x1bW4gPT09ICdudW1iZXInLCAnZXhwZWN0ZWQgYHRhYmxlQ29sdW1uYCcpXG4gICAgICBjb25zdCBhbGlnbiA9IGFsaWdubWVudFt0YWJsZUFsaWduW3RhYmxlQ29sdW1uXV1cblxuICAgICAgaWYgKGFsaWduID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gQ2FwdHVyZSByZXN1bHRzIHRvIGlnbm9yZSB0aGVtLlxuICAgICAgICB0aGlzLmJ1ZmZlcigpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgICAgIHRoaXMudGFnKCc8dGQnICsgYWxpZ24gKyAnPicpXG4gICAgICB9XG4gICAgfSxcbiAgICB0YWJsZUhlYWQoKSB7XG4gICAgICB0aGlzLmxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgICB0aGlzLnRhZygnPHRoZWFkPicpXG4gICAgfSxcbiAgICB0YWJsZUhlYWRlcigpIHtcbiAgICAgIGNvbnN0IHRhYmxlQWxpZ24gPSB0aGlzLmdldERhdGEoJ3RhYmxlQWxpZ24nKVxuICAgICAgY29uc3QgdGFibGVDb2x1bW4gPSB0aGlzLmdldERhdGEoJ3RhYmxlQ29sdW1uJylcbiAgICAgIGFzc2VydCh0YWJsZUFsaWduLCAnZXhwZWN0ZWQgYHRhYmxlQWxpZ25gJylcbiAgICAgIGFzc2VydCh0eXBlb2YgdGFibGVDb2x1bW4gPT09ICdudW1iZXInLCAnZXhwZWN0ZWQgYHRhYmxlQ29sdW1uYCcpXG4gICAgICBjb25zdCBhbGlnbiA9IGFsaWdubWVudFt0YWJsZUFsaWduW3RhYmxlQ29sdW1uXV1cbiAgICAgIHRoaXMubGluZUVuZGluZ0lmTmVlZGVkKClcbiAgICAgIHRoaXMudGFnKCc8dGgnICsgYWxpZ24gKyAnPicpXG4gICAgfSxcbiAgICB0YWJsZVJvdygpIHtcbiAgICAgIHRoaXMuc2V0RGF0YSgndGFibGVDb2x1bW4nLCAwKVxuICAgICAgdGhpcy5saW5lRW5kaW5nSWZOZWVkZWQoKVxuICAgICAgdGhpcy50YWcoJzx0cj4nKVxuICAgIH1cbiAgfSxcbiAgZXhpdDoge1xuICAgIC8vIE92ZXJ3cml0ZSB0aGUgZGVmYXVsdCBjb2RlIHRleHQgZGF0YSBoYW5kbGVyIHRvIHVuZXNjYXBlIGVzY2FwZWQgcGlwZXMgd2hlblxuICAgIC8vIHRoZXkgYXJlIGluIHRhYmxlcy5cbiAgICBjb2RlVGV4dERhdGEodG9rZW4pIHtcbiAgICAgIGxldCB2YWx1ZSA9IHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pXG5cbiAgICAgIGlmICh0aGlzLmdldERhdGEoJ3RhYmxlQWxpZ24nKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcXFwoW1xcXFx8XSkvZywgcmVwbGFjZSlcbiAgICAgIH1cblxuICAgICAgdGhpcy5yYXcodGhpcy5lbmNvZGUodmFsdWUpKVxuICAgIH0sXG4gICAgdGFibGUoKSB7XG4gICAgICB0aGlzLnNldERhdGEoJ3RhYmxlQWxpZ24nKVxuICAgICAgLy8gTm90ZTogd2UgZG9u4oCZdCBzZXQgYHNsdXJwQWxsTGluZUVuZGluZ3NgIGFueW1vcmUsIGluIGRlbGltaXRlciByb3dzLFxuICAgICAgLy8gYnV0IHdlIGRvIG5lZWQgdG8gcmVzZXQgaXQgdG8gbWF0Y2ggYSBmdW5reSBuZXdsaW5lIEdIIGdlbmVyYXRlcyBmb3JcbiAgICAgIC8vIGxpc3QgaXRlbXMgY29tYmluZWQgd2l0aCB0YWJsZXMuXG4gICAgICB0aGlzLnNldERhdGEoJ3NsdXJwQWxsTGluZUVuZGluZ3MnKVxuICAgICAgdGhpcy5saW5lRW5kaW5nSWZOZWVkZWQoKVxuICAgICAgdGhpcy50YWcoJzwvdGFibGU+JylcbiAgICB9LFxuICAgIHRhYmxlQm9keSgpIHtcbiAgICAgIHRoaXMubGluZUVuZGluZ0lmTmVlZGVkKClcbiAgICAgIHRoaXMudGFnKCc8L3Rib2R5PicpXG4gICAgfSxcbiAgICB0YWJsZURhdGEoKSB7XG4gICAgICBjb25zdCB0YWJsZUFsaWduID0gdGhpcy5nZXREYXRhKCd0YWJsZUFsaWduJylcbiAgICAgIGNvbnN0IHRhYmxlQ29sdW1uID0gdGhpcy5nZXREYXRhKCd0YWJsZUNvbHVtbicpXG4gICAgICBhc3NlcnQodGFibGVBbGlnbiwgJ2V4cGVjdGVkIGB0YWJsZUFsaWduYCcpXG4gICAgICBhc3NlcnQodHlwZW9mIHRhYmxlQ29sdW1uID09PSAnbnVtYmVyJywgJ2V4cGVjdGVkIGB0YWJsZUNvbHVtbmAnKVxuXG4gICAgICBpZiAodGFibGVDb2x1bW4gaW4gdGFibGVBbGlnbikge1xuICAgICAgICB0aGlzLnRhZygnPC90ZD4nKVxuICAgICAgICB0aGlzLnNldERhdGEoJ3RhYmxlQ29sdW1uJywgdGFibGVDb2x1bW4gKyAxKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3RvcCBjYXB0dXJpbmcuXG4gICAgICAgIHRoaXMucmVzdW1lKClcbiAgICAgIH1cbiAgICB9LFxuICAgIHRhYmxlSGVhZCgpIHtcbiAgICAgIHRoaXMubGluZUVuZGluZ0lmTmVlZGVkKClcbiAgICAgIHRoaXMudGFnKCc8L3RoZWFkPicpXG4gICAgfSxcbiAgICB0YWJsZUhlYWRlcigpIHtcbiAgICAgIGNvbnN0IHRhYmxlQ29sdW1uID0gdGhpcy5nZXREYXRhKCd0YWJsZUNvbHVtbicpXG4gICAgICBhc3NlcnQodHlwZW9mIHRhYmxlQ29sdW1uID09PSAnbnVtYmVyJywgJ2V4cGVjdGVkIGB0YWJsZUNvbHVtbmAnKVxuICAgICAgdGhpcy50YWcoJzwvdGg+JylcbiAgICAgIHRoaXMuc2V0RGF0YSgndGFibGVDb2x1bW4nLCB0YWJsZUNvbHVtbiArIDEpXG4gICAgfSxcbiAgICB0YWJsZVJvdygpIHtcbiAgICAgIGNvbnN0IHRhYmxlQWxpZ24gPSB0aGlzLmdldERhdGEoJ3RhYmxlQWxpZ24nKVxuICAgICAgbGV0IHRhYmxlQ29sdW1uID0gdGhpcy5nZXREYXRhKCd0YWJsZUNvbHVtbicpXG4gICAgICBhc3NlcnQodGFibGVBbGlnbiwgJ2V4cGVjdGVkIGB0YWJsZUFsaWduYCcpXG4gICAgICBhc3NlcnQodHlwZW9mIHRhYmxlQ29sdW1uID09PSAnbnVtYmVyJywgJ2V4cGVjdGVkIGB0YWJsZUNvbHVtbmAnKVxuXG4gICAgICB3aGlsZSAodGFibGVDb2x1bW4gPCB0YWJsZUFsaWduLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgICAgIHRoaXMudGFnKCc8dGQnICsgYWxpZ25tZW50W3RhYmxlQWxpZ25bdGFibGVDb2x1bW5dXSArICc+PC90ZD4nKVxuICAgICAgICB0YWJsZUNvbHVtbisrXG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0RGF0YSgndGFibGVDb2x1bW4nLCB0YWJsZUNvbHVtbilcbiAgICAgIHRoaXMubGluZUVuZGluZ0lmTmVlZGVkKClcbiAgICAgIHRoaXMudGFnKCc8L3RyPicpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9ICQwXG4gKiBAcGFyYW0ge3N0cmluZ30gJDFcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJlcGxhY2UoJDAsICQxKSB7XG4gIC8vIFBpcGVzIHdvcmssIGJhY2tzbGFzaGVzIGRvbuKAmXQgKGJ1dCBjYW7igJl0IGVzY2FwZSBwaXBlcykuXG4gIHJldHVybiAkMSA9PT0gJ3wnID8gJDEgOiAkMFxufVxuIl0sIm5hbWVzIjpbIm9rIiwiYXNzZXJ0IiwiYWxpZ25tZW50Iiwibm9uZSIsImxlZnQiLCJyaWdodCIsImNlbnRlciIsImdmbVRhYmxlSHRtbCIsImVudGVyIiwidGFibGUiLCJ0b2tlbiIsInRhYmxlQWxpZ24iLCJfYWxpZ24iLCJsaW5lRW5kaW5nSWZOZWVkZWQiLCJ0YWciLCJzZXREYXRhIiwidGFibGVCb2R5IiwidGFibGVEYXRhIiwiZ2V0RGF0YSIsInRhYmxlQ29sdW1uIiwiYWxpZ24iLCJ1bmRlZmluZWQiLCJidWZmZXIiLCJ0YWJsZUhlYWQiLCJ0YWJsZUhlYWRlciIsInRhYmxlUm93IiwiZXhpdCIsImNvZGVUZXh0RGF0YSIsInZhbHVlIiwic2xpY2VTZXJpYWxpemUiLCJyZXBsYWNlIiwicmF3IiwiZW5jb2RlIiwicmVzdW1lIiwibGVuZ3RoIiwiJDAiLCIkMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/micromark-extension-gfm-table/dev/lib/html.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/micromark-extension-gfm-table/dev/lib/infer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-table/dev/lib/infer.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmTableAlign: () => (/* binding */ gfmTableAlign)\n/* harmony export */ });\n/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uvu/assert */ \"(ssr)/./node_modules/uvu/assert/index.mjs\");\n/**\n * @typedef {import('micromark-util-types').Event} Event\n */ /**\n * @typedef {'left' | 'center' | 'right' | 'none'} Align\n */ \n/**\n * Figure out the alignment of a GFM table.\n *\n * @param {Array<Event>} events\n * @param {number} index\n * @returns {Array<Align>}\n */ function gfmTableAlign(events, index) {\n    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(events[index][1].type === \"table\", \"expected table\");\n    let inDelimiterRow = false;\n    /** @type {Array<Align>} */ const align = [];\n    while(index < events.length){\n        const event = events[index];\n        if (inDelimiterRow) {\n            if (event[0] === \"enter\") {\n                // Start of alignment value: set a new column.\n                // To do: `markdown-rs` uses `tableDelimiterCellValue`.\n                if (event[1].type === \"tableContent\") {\n                    align.push(events[index + 1][1].type === \"tableDelimiterMarker\" ? \"left\" : \"none\");\n                }\n            } else if (event[1].type === \"tableContent\") {\n                if (events[index - 1][1].type === \"tableDelimiterMarker\") {\n                    const alignIndex = align.length - 1;\n                    align[alignIndex] = align[alignIndex] === \"left\" ? \"center\" : \"right\";\n                }\n            } else if (event[1].type === \"tableDelimiterRow\") {\n                break;\n            }\n        } else if (event[0] === \"enter\" && event[1].type === \"tableDelimiterRow\") {\n            inDelimiterRow = true;\n        }\n        index += 1;\n    }\n    return align;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFibGUvZGV2L2xpYi9pbmZlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOztDQUVDLEdBRUQ7O0NBRUMsR0FFc0M7QUFFdkM7Ozs7OztDQU1DLEdBQ00sU0FBU0UsY0FBY0MsTUFBTSxFQUFFQyxLQUFLO0lBQ3pDSCw4Q0FBTUEsQ0FBQ0UsTUFBTSxDQUFDQyxNQUFNLENBQUMsRUFBRSxDQUFDQyxJQUFJLEtBQUssU0FBUztJQUMxQyxJQUFJQyxpQkFBaUI7SUFDckIseUJBQXlCLEdBQ3pCLE1BQU1DLFFBQVEsRUFBRTtJQUVoQixNQUFPSCxRQUFRRCxPQUFPSyxNQUFNLENBQUU7UUFDNUIsTUFBTUMsUUFBUU4sTUFBTSxDQUFDQyxNQUFNO1FBRTNCLElBQUlFLGdCQUFnQjtZQUNsQixJQUFJRyxLQUFLLENBQUMsRUFBRSxLQUFLLFNBQVM7Z0JBQ3hCLDhDQUE4QztnQkFDOUMsdURBQXVEO2dCQUN2RCxJQUFJQSxLQUFLLENBQUMsRUFBRSxDQUFDSixJQUFJLEtBQUssZ0JBQWdCO29CQUNwQ0UsTUFBTUcsSUFBSSxDQUNSUCxNQUFNLENBQUNDLFFBQVEsRUFBRSxDQUFDLEVBQUUsQ0FBQ0MsSUFBSSxLQUFLLHlCQUMxQixTQUNBO2dCQUVSO1lBQ0YsT0FJSyxJQUFJSSxLQUFLLENBQUMsRUFBRSxDQUFDSixJQUFJLEtBQUssZ0JBQWdCO2dCQUN6QyxJQUFJRixNQUFNLENBQUNDLFFBQVEsRUFBRSxDQUFDLEVBQUUsQ0FBQ0MsSUFBSSxLQUFLLHdCQUF3QjtvQkFDeEQsTUFBTU0sYUFBYUosTUFBTUMsTUFBTSxHQUFHO29CQUVsQ0QsS0FBSyxDQUFDSSxXQUFXLEdBQUdKLEtBQUssQ0FBQ0ksV0FBVyxLQUFLLFNBQVMsV0FBVztnQkFDaEU7WUFDRixPQUVLLElBQUlGLEtBQUssQ0FBQyxFQUFFLENBQUNKLElBQUksS0FBSyxxQkFBcUI7Z0JBQzlDO1lBQ0Y7UUFDRixPQUFPLElBQUlJLEtBQUssQ0FBQyxFQUFFLEtBQUssV0FBV0EsS0FBSyxDQUFDLEVBQUUsQ0FBQ0osSUFBSSxLQUFLLHFCQUFxQjtZQUN4RUMsaUJBQWlCO1FBQ25CO1FBRUFGLFNBQVM7SUFDWDtJQUVBLE9BQU9HO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92MCBjbG9uZSB3aXRoIGNvcGlsb3RraXQsIG5leHQuanMsIGFuZCBvcGVuYWkgZ3B0NC8uL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS10YWJsZS9kZXYvbGliL2luZmVyLmpzPzUxNjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkV2ZW50fSBFdmVudFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeydsZWZ0JyB8ICdjZW50ZXInIHwgJ3JpZ2h0JyB8ICdub25lJ30gQWxpZ25cbiAqL1xuXG5pbXBvcnQge29rIGFzIGFzc2VydH0gZnJvbSAndXZ1L2Fzc2VydCdcblxuLyoqXG4gKiBGaWd1cmUgb3V0IHRoZSBhbGlnbm1lbnQgb2YgYSBHRk0gdGFibGUuXG4gKlxuICogQHBhcmFtIHtBcnJheTxFdmVudD59IGV2ZW50c1xuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcmV0dXJucyB7QXJyYXk8QWxpZ24+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2ZtVGFibGVBbGlnbihldmVudHMsIGluZGV4KSB7XG4gIGFzc2VydChldmVudHNbaW5kZXhdWzFdLnR5cGUgPT09ICd0YWJsZScsICdleHBlY3RlZCB0YWJsZScpXG4gIGxldCBpbkRlbGltaXRlclJvdyA9IGZhbHNlXG4gIC8qKiBAdHlwZSB7QXJyYXk8QWxpZ24+fSAqL1xuICBjb25zdCBhbGlnbiA9IFtdXG5cbiAgd2hpbGUgKGluZGV4IDwgZXZlbnRzLmxlbmd0aCkge1xuICAgIGNvbnN0IGV2ZW50ID0gZXZlbnRzW2luZGV4XVxuXG4gICAgaWYgKGluRGVsaW1pdGVyUm93KSB7XG4gICAgICBpZiAoZXZlbnRbMF0gPT09ICdlbnRlcicpIHtcbiAgICAgICAgLy8gU3RhcnQgb2YgYWxpZ25tZW50IHZhbHVlOiBzZXQgYSBuZXcgY29sdW1uLlxuICAgICAgICAvLyBUbyBkbzogYG1hcmtkb3duLXJzYCB1c2VzIGB0YWJsZURlbGltaXRlckNlbGxWYWx1ZWAuXG4gICAgICAgIGlmIChldmVudFsxXS50eXBlID09PSAndGFibGVDb250ZW50Jykge1xuICAgICAgICAgIGFsaWduLnB1c2goXG4gICAgICAgICAgICBldmVudHNbaW5kZXggKyAxXVsxXS50eXBlID09PSAndGFibGVEZWxpbWl0ZXJNYXJrZXInXG4gICAgICAgICAgICAgID8gJ2xlZnQnXG4gICAgICAgICAgICAgIDogJ25vbmUnXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBFeGl0czpcbiAgICAgIC8vIEVuZCBvZiBhbGlnbm1lbnQgdmFsdWU6IGNoYW5nZSB0aGUgY29sdW1uLlxuICAgICAgLy8gVG8gZG86IGBtYXJrZG93bi1yc2AgdXNlcyBgdGFibGVEZWxpbWl0ZXJDZWxsVmFsdWVgLlxuICAgICAgZWxzZSBpZiAoZXZlbnRbMV0udHlwZSA9PT0gJ3RhYmxlQ29udGVudCcpIHtcbiAgICAgICAgaWYgKGV2ZW50c1tpbmRleCAtIDFdWzFdLnR5cGUgPT09ICd0YWJsZURlbGltaXRlck1hcmtlcicpIHtcbiAgICAgICAgICBjb25zdCBhbGlnbkluZGV4ID0gYWxpZ24ubGVuZ3RoIC0gMVxuXG4gICAgICAgICAgYWxpZ25bYWxpZ25JbmRleF0gPSBhbGlnblthbGlnbkluZGV4XSA9PT0gJ2xlZnQnID8gJ2NlbnRlcicgOiAncmlnaHQnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIERvbmUhXG4gICAgICBlbHNlIGlmIChldmVudFsxXS50eXBlID09PSAndGFibGVEZWxpbWl0ZXJSb3cnKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChldmVudFswXSA9PT0gJ2VudGVyJyAmJiBldmVudFsxXS50eXBlID09PSAndGFibGVEZWxpbWl0ZXJSb3cnKSB7XG4gICAgICBpbkRlbGltaXRlclJvdyA9IHRydWVcbiAgICB9XG5cbiAgICBpbmRleCArPSAxXG4gIH1cblxuICByZXR1cm4gYWxpZ25cbn1cbiJdLCJuYW1lcyI6WyJvayIsImFzc2VydCIsImdmbVRhYmxlQWxpZ24iLCJldmVudHMiLCJpbmRleCIsInR5cGUiLCJpbkRlbGltaXRlclJvdyIsImFsaWduIiwibGVuZ3RoIiwiZXZlbnQiLCJwdXNoIiwiYWxpZ25JbmRleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/micromark-extension-gfm-table/dev/lib/infer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/micromark-extension-gfm-table/dev/lib/syntax.js":
/*!**********************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-table/dev/lib/syntax.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmTable: () => (/* binding */ gfmTable)\n/* harmony export */ });\n/* harmony import */ var uvu_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uvu/assert */ \"(ssr)/./node_modules/uvu/assert/index.mjs\");\n/* harmony import */ var micromark_factory_space__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-factory-space */ \"(ssr)/./node_modules/micromark-factory-space/dev/index.js\");\n/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-character */ \"(ssr)/./node_modules/micromark-util-character/dev/index.js\");\n/* harmony import */ var micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-symbol/codes.js */ \"(ssr)/./node_modules/micromark-util-symbol/codes.js\");\n/* harmony import */ var micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! micromark-util-symbol/constants.js */ \"(ssr)/./node_modules/micromark-util-symbol/constants.js\");\n/* harmony import */ var micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-symbol/types.js */ \"(ssr)/./node_modules/micromark-util-symbol/types.js\");\n/* harmony import */ var _edit_map_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./edit-map.js */ \"(ssr)/./node_modules/micromark-extension-gfm-table/dev/lib/edit-map.js\");\n/* harmony import */ var _infer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./infer.js */ \"(ssr)/./node_modules/micromark-extension-gfm-table/dev/lib/infer.js\");\n/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Point} Point\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */ /**\n * @typedef {[number, number, number, number]} Range\n *   Cell info.\n *\n * @typedef {0 | 1 | 2 | 3} RowKind\n *   Where we are: `1` for head row, `2` for delimiter row, `3` for body row.\n */ \n\n\n\n\n\n\n\n// To do: next major: expose functions.\n/**\n * Extension for `micromark` that can be passed in `extensions` to enable GFM\n * table syntax.\n *\n * @type {Extension}\n */ const gfmTable = {\n    flow: {\n        null: {\n            tokenize: tokenizeTable,\n            resolveAll: resolveTable\n        }\n    }\n};\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */ function tokenizeTable(effects, ok, nok) {\n    const self = this;\n    let size = 0;\n    let sizeB = 0;\n    /** @type {boolean | undefined} */ let seen;\n    return start;\n    /**\n   * Start of a GFM table.\n   *\n   * If there is a valid table row or table head before, then we try to parse\n   * another row.\n   * Otherwise, we try to parse a head.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *   | | - |\n   * > | | b |\n   *     ^\n   * ```\n   * @type {State}\n   */ function start(code) {\n        let index = self.events.length - 1;\n        while(index > -1){\n            const type = self.events[index][1].type;\n            if (type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.lineEnding || // Note: markdown-rs uses `whitespace` instead of `linePrefix`\n            type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.linePrefix) index--;\n            else break;\n        }\n        const tail = index > -1 ? self.events[index][1].type : null;\n        const next = tail === \"tableHead\" || tail === \"tableRow\" ? bodyRowStart : headRowBefore;\n        // Don’t allow lazy body rows.\n        if (next === bodyRowStart && self.parser.lazy[self.now().line]) {\n            return nok(code);\n        }\n        return next(code);\n    }\n    /**\n   * Before table head row.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */ function headRowBefore(code) {\n        effects.enter(\"tableHead\");\n        effects.enter(\"tableRow\");\n        return headRowStart(code);\n    }\n    /**\n   * Before table head row, after whitespace.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */ function headRowStart(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.verticalBar) {\n            return headRowBreak(code);\n        }\n        // To do: micromark-js should let us parse our own whitespace in extensions,\n        // like `markdown-rs`:\n        //\n        // ```js\n        // // 4+ spaces.\n        // if (markdownSpace(code)) {\n        //   return nok(code)\n        // }\n        // ```\n        seen = true;\n        // Count the first character, that isn’t a pipe, double.\n        sizeB += 1;\n        return headRowBreak(code);\n    }\n    /**\n   * At break in table head row.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *       ^\n   *         ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */ function headRowBreak(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof) {\n            // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.\n            return nok(code);\n        }\n        if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownLineEnding)(code)) {\n            // If anything other than one pipe (ignoring whitespace) was used, it’s fine.\n            if (sizeB > 1) {\n                sizeB = 0;\n                // To do: check if this works.\n                // Feel free to interrupt:\n                self.interrupt = true;\n                effects.exit(\"tableRow\");\n                effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.lineEnding);\n                effects.consume(code);\n                effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.lineEnding);\n                return headDelimiterStart;\n            }\n            // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.\n            return nok(code);\n        }\n        if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownSpace)(code)) {\n            // To do: check if this is fine.\n            // effects.attempt(State::Next(StateName::GfmTableHeadRowBreak), State::Nok)\n            // State::Retry(space_or_tab(tokenizer))\n            return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_4__.factorySpace)(effects, headRowBreak, micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.whitespace)(code);\n        }\n        sizeB += 1;\n        if (seen) {\n            seen = false;\n            // Header cell count.\n            size += 1;\n        }\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.verticalBar) {\n            effects.enter(\"tableCellDivider\");\n            effects.consume(code);\n            effects.exit(\"tableCellDivider\");\n            // Whether a delimiter was seen.\n            seen = true;\n            return headRowBreak;\n        }\n        // Anything else is cell data.\n        effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.data);\n        return headRowData(code);\n    }\n    /**\n   * In table head row data.\n   *\n   * ```markdown\n   * > | | a |\n   *       ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */ function headRowData(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.verticalBar || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownLineEndingOrSpace)(code)) {\n            effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.data);\n            return headRowBreak(code);\n        }\n        effects.consume(code);\n        return code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.backslash ? headRowEscape : headRowData;\n    }\n    /**\n   * In table head row escape.\n   *\n   * ```markdown\n   * > | | a\\-b |\n   *         ^\n   *   | | ---- |\n   *   | | c    |\n   * ```\n   *\n   * @type {State}\n   */ function headRowEscape(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.backslash || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.verticalBar) {\n            effects.consume(code);\n            return headRowData;\n        }\n        return headRowData(code);\n    }\n    /**\n   * Before delimiter row.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *     ^\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */ function headDelimiterStart(code) {\n        // Reset `interrupt`.\n        self.interrupt = false;\n        // Note: in `markdown-rs`, we need to handle piercing here too.\n        if (self.parser.lazy[self.now().line]) {\n            return nok(code);\n        }\n        effects.enter(\"tableDelimiterRow\");\n        // Track if we’ve seen a `:` or `|`.\n        seen = false;\n        if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownSpace)(code)) {\n            (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(self.parser.constructs.disable.null, \"expected `disabled.null`\");\n            return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_4__.factorySpace)(effects, headDelimiterBefore, micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.linePrefix, self.parser.constructs.disable.null.includes(\"codeIndented\") ? undefined : micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_5__.constants.tabSize)(code);\n        }\n        return headDelimiterBefore(code);\n    }\n    /**\n   * Before delimiter row, after optional whitespace.\n   *\n   * Reused when a `|` is found later, to parse another cell.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *     ^\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */ function headDelimiterBefore(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dash || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.colon) {\n            return headDelimiterValueBefore(code);\n        }\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.verticalBar) {\n            seen = true;\n            // If we start with a pipe, we open a cell marker.\n            effects.enter(\"tableCellDivider\");\n            effects.consume(code);\n            effects.exit(\"tableCellDivider\");\n            return headDelimiterCellBefore;\n        }\n        // More whitespace / empty row not allowed at start.\n        return headDelimiterNok(code);\n    }\n    /**\n   * After `|`, before delimiter cell.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */ function headDelimiterCellBefore(code) {\n        if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownSpace)(code)) {\n            return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_4__.factorySpace)(effects, headDelimiterValueBefore, micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.whitespace)(code);\n        }\n        return headDelimiterValueBefore(code);\n    }\n    /**\n   * Before delimiter cell value.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */ function headDelimiterValueBefore(code) {\n        // Align: left.\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.colon) {\n            sizeB += 1;\n            seen = true;\n            effects.enter(\"tableDelimiterMarker\");\n            effects.consume(code);\n            effects.exit(\"tableDelimiterMarker\");\n            return headDelimiterLeftAlignmentAfter;\n        }\n        // Align: none.\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dash) {\n            sizeB += 1;\n            // To do: seems weird that this *isn’t* left aligned, but that state is used?\n            return headDelimiterLeftAlignmentAfter(code);\n        }\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownLineEnding)(code)) {\n            return headDelimiterCellAfter(code);\n        }\n        return headDelimiterNok(code);\n    }\n    /**\n   * After delimiter cell left alignment marker.\n   *\n   * ```markdown\n   *   | | a  |\n   * > | | :- |\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */ function headDelimiterLeftAlignmentAfter(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dash) {\n            effects.enter(\"tableDelimiterFiller\");\n            return headDelimiterFiller(code);\n        }\n        // Anything else is not ok after the left-align colon.\n        return headDelimiterNok(code);\n    }\n    /**\n   * In delimiter cell filler.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */ function headDelimiterFiller(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.dash) {\n            effects.consume(code);\n            return headDelimiterFiller;\n        }\n        // Align is `center` if it was `left`, `right` otherwise.\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.colon) {\n            seen = true;\n            effects.exit(\"tableDelimiterFiller\");\n            effects.enter(\"tableDelimiterMarker\");\n            effects.consume(code);\n            effects.exit(\"tableDelimiterMarker\");\n            return headDelimiterRightAlignmentAfter;\n        }\n        effects.exit(\"tableDelimiterFiller\");\n        return headDelimiterRightAlignmentAfter(code);\n    }\n    /**\n   * After delimiter cell right alignment marker.\n   *\n   * ```markdown\n   *   | |  a |\n   * > | | -: |\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */ function headDelimiterRightAlignmentAfter(code) {\n        if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownSpace)(code)) {\n            return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_4__.factorySpace)(effects, headDelimiterCellAfter, micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.whitespace)(code);\n        }\n        return headDelimiterCellAfter(code);\n    }\n    /**\n   * After delimiter cell.\n   *\n   * ```markdown\n   *   | |  a |\n   * > | | -: |\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */ function headDelimiterCellAfter(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.verticalBar) {\n            return headDelimiterBefore(code);\n        }\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownLineEnding)(code)) {\n            // Exit when:\n            // * there was no `:` or `|` at all (it’s a thematic break or setext\n            //   underline instead)\n            // * the header cell count is not the delimiter cell count\n            if (!seen || size !== sizeB) {\n                return headDelimiterNok(code);\n            }\n            // Note: in markdown-rs`, a reset is needed here.\n            effects.exit(\"tableDelimiterRow\");\n            effects.exit(\"tableHead\");\n            // To do: in `markdown-rs`, resolvers need to be registered manually.\n            // effects.register_resolver(ResolveName::GfmTable)\n            return ok(code);\n        }\n        return headDelimiterNok(code);\n    }\n    /**\n   * In delimiter row, at a disallowed byte.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | x |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */ function headDelimiterNok(code) {\n        // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.\n        return nok(code);\n    }\n    /**\n   * Before table body row.\n   *\n   * ```markdown\n   *   | | a |\n   *   | | - |\n   * > | | b |\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */ function bodyRowStart(code) {\n        // Note: in `markdown-rs` we need to manually take care of a prefix,\n        // but in `micromark-js` that is done for us, so if we’re here, we’re\n        // never at whitespace.\n        effects.enter(\"tableRow\");\n        return bodyRowBreak(code);\n    }\n    /**\n   * At break in table body row.\n   *\n   * ```markdown\n   *   | | a |\n   *   | | - |\n   * > | | b |\n   *     ^\n   *       ^\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */ function bodyRowBreak(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.verticalBar) {\n            effects.enter(\"tableCellDivider\");\n            effects.consume(code);\n            effects.exit(\"tableCellDivider\");\n            return bodyRowBreak;\n        }\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownLineEnding)(code)) {\n            effects.exit(\"tableRow\");\n            return ok(code);\n        }\n        if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownSpace)(code)) {\n            return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_4__.factorySpace)(effects, bodyRowBreak, micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.whitespace)(code);\n        }\n        // Anything else is cell content.\n        effects.enter(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.data);\n        return bodyRowData(code);\n    }\n    /**\n   * In table body row data.\n   *\n   * ```markdown\n   *   | | a |\n   *   | | - |\n   * > | | b |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */ function bodyRowData(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.eof || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.verticalBar || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.markdownLineEndingOrSpace)(code)) {\n            effects.exit(micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.data);\n            return bodyRowBreak(code);\n        }\n        effects.consume(code);\n        return code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.backslash ? bodyRowEscape : bodyRowData;\n    }\n    /**\n   * In table body row escape.\n   *\n   * ```markdown\n   *   | | a    |\n   *   | | ---- |\n   * > | | b\\-c |\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */ function bodyRowEscape(code) {\n        if (code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.backslash || code === micromark_util_symbol_codes_js__WEBPACK_IMPORTED_MODULE_2__.codes.verticalBar) {\n            effects.consume(code);\n            return bodyRowData;\n        }\n        return bodyRowData(code);\n    }\n}\n/** @type {Resolver} */ // eslint-disable-next-line complexity\nfunction resolveTable(events, context) {\n    let index = -1;\n    let inFirstCellAwaitingPipe = true;\n    /** @type {RowKind} */ let rowKind = 0;\n    /** @type {Range} */ let lastCell = [\n        0,\n        0,\n        0,\n        0\n    ];\n    /** @type {Range} */ let cell = [\n        0,\n        0,\n        0,\n        0\n    ];\n    let afterHeadAwaitingFirstBodyRow = false;\n    let lastTableEnd = 0;\n    /** @type {Token | undefined} */ let currentTable;\n    /** @type {Token | undefined} */ let currentBody;\n    /** @type {Token | undefined} */ let currentCell;\n    const map = new _edit_map_js__WEBPACK_IMPORTED_MODULE_6__.EditMap();\n    while(++index < events.length){\n        const event = events[index];\n        const token = event[1];\n        if (event[0] === \"enter\") {\n            // Start of head.\n            if (token.type === \"tableHead\") {\n                afterHeadAwaitingFirstBodyRow = false;\n                // Inject previous (body end and) table end.\n                if (lastTableEnd !== 0) {\n                    (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(currentTable, \"there should be a table opening\");\n                    flushTableEnd(map, context, lastTableEnd, currentTable, currentBody);\n                    currentBody = undefined;\n                    lastTableEnd = 0;\n                }\n                // Inject table start.\n                currentTable = {\n                    type: \"table\",\n                    start: Object.assign({}, token.start),\n                    // Note: correct end is set later.\n                    end: Object.assign({}, token.end)\n                };\n                map.add(index, 0, [\n                    [\n                        \"enter\",\n                        currentTable,\n                        context\n                    ]\n                ]);\n            } else if (token.type === \"tableRow\" || token.type === \"tableDelimiterRow\") {\n                inFirstCellAwaitingPipe = true;\n                currentCell = undefined;\n                lastCell = [\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n                cell = [\n                    0,\n                    index + 1,\n                    0,\n                    0\n                ];\n                // Inject table body start.\n                if (afterHeadAwaitingFirstBodyRow) {\n                    afterHeadAwaitingFirstBodyRow = false;\n                    currentBody = {\n                        type: \"tableBody\",\n                        start: Object.assign({}, token.start),\n                        // Note: correct end is set later.\n                        end: Object.assign({}, token.end)\n                    };\n                    map.add(index, 0, [\n                        [\n                            \"enter\",\n                            currentBody,\n                            context\n                        ]\n                    ]);\n                }\n                rowKind = token.type === \"tableDelimiterRow\" ? 2 : currentBody ? 3 : 1;\n            } else if (rowKind && (token.type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.data || token.type === \"tableDelimiterMarker\" || token.type === \"tableDelimiterFiller\")) {\n                inFirstCellAwaitingPipe = false;\n                // First value in cell.\n                if (cell[2] === 0) {\n                    if (lastCell[1] !== 0) {\n                        cell[0] = cell[1];\n                        currentCell = flushCell(map, context, lastCell, rowKind, undefined, currentCell);\n                        lastCell = [\n                            0,\n                            0,\n                            0,\n                            0\n                        ];\n                    }\n                    cell[2] = index;\n                }\n            } else if (token.type === \"tableCellDivider\") {\n                if (inFirstCellAwaitingPipe) {\n                    inFirstCellAwaitingPipe = false;\n                } else {\n                    if (lastCell[1] !== 0) {\n                        cell[0] = cell[1];\n                        currentCell = flushCell(map, context, lastCell, rowKind, undefined, currentCell);\n                    }\n                    lastCell = cell;\n                    cell = [\n                        lastCell[1],\n                        index,\n                        0,\n                        0\n                    ];\n                }\n            }\n        } else if (token.type === \"tableHead\") {\n            afterHeadAwaitingFirstBodyRow = true;\n            lastTableEnd = index;\n        } else if (token.type === \"tableRow\" || token.type === \"tableDelimiterRow\") {\n            lastTableEnd = index;\n            if (lastCell[1] !== 0) {\n                cell[0] = cell[1];\n                currentCell = flushCell(map, context, lastCell, rowKind, index, currentCell);\n            } else if (cell[1] !== 0) {\n                currentCell = flushCell(map, context, cell, rowKind, index, currentCell);\n            }\n            rowKind = 0;\n        } else if (rowKind && (token.type === micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.data || token.type === \"tableDelimiterMarker\" || token.type === \"tableDelimiterFiller\")) {\n            cell[3] = index;\n        }\n    }\n    if (lastTableEnd !== 0) {\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(currentTable, \"expected table opening\");\n        flushTableEnd(map, context, lastTableEnd, currentTable, currentBody);\n    }\n    map.consume(context.events);\n    // To do: move this into `html`, when events are exposed there.\n    // That’s what `markdown-rs` does.\n    // That needs updates to `mdast-util-gfm-table`.\n    index = -1;\n    while(++index < context.events.length){\n        const event = context.events[index];\n        if (event[0] === \"enter\" && event[1].type === \"table\") {\n            event[1]._align = (0,_infer_js__WEBPACK_IMPORTED_MODULE_7__.gfmTableAlign)(context.events, index);\n        }\n    }\n    return events;\n}\n/// Generate a cell.\n/**\n *\n * @param {EditMap} map\n * @param {TokenizeContext} context\n * @param {Range} range\n * @param {RowKind} rowKind\n * @param {number | undefined} rowEnd\n * @param {Token | undefined} previousCell\n * @returns {Token | undefined}\n */ // eslint-disable-next-line max-params\nfunction flushCell(map, context, range, rowKind, rowEnd, previousCell) {\n    // `markdown-rs` uses:\n    // rowKind === 2 ? 'tableDelimiterCell' : 'tableCell'\n    const groupName = rowKind === 1 ? \"tableHeader\" : rowKind === 2 ? \"tableDelimiter\" : \"tableData\";\n    // `markdown-rs` uses:\n    // rowKind === 2 ? 'tableDelimiterCellValue' : 'tableCellText'\n    const valueName = \"tableContent\";\n    // Insert an exit for the previous cell, if there is one.\n    //\n    // ```markdown\n    // > | | aa | bb | cc |\n    //          ^-- exit\n    //           ^^^^-- this cell\n    // ```\n    if (range[0] !== 0) {\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(previousCell, \"expected previous cell enter\");\n        previousCell.end = Object.assign({}, getPoint(context.events, range[0]));\n        map.add(range[0], 0, [\n            [\n                \"exit\",\n                previousCell,\n                context\n            ]\n        ]);\n    }\n    // Insert enter of this cell.\n    //\n    // ```markdown\n    // > | | aa | bb | cc |\n    //           ^-- enter\n    //           ^^^^-- this cell\n    // ```\n    const now = getPoint(context.events, range[1]);\n    previousCell = {\n        type: groupName,\n        start: Object.assign({}, now),\n        // Note: correct end is set later.\n        end: Object.assign({}, now)\n    };\n    map.add(range[1], 0, [\n        [\n            \"enter\",\n            previousCell,\n            context\n        ]\n    ]);\n    // Insert text start at first data start and end at last data end, and\n    // remove events between.\n    //\n    // ```markdown\n    // > | | aa | bb | cc |\n    //            ^-- enter\n    //             ^-- exit\n    //           ^^^^-- this cell\n    // ```\n    if (range[2] !== 0) {\n        const relatedStart = getPoint(context.events, range[2]);\n        const relatedEnd = getPoint(context.events, range[3]);\n        /** @type {Token} */ const valueToken = {\n            type: valueName,\n            start: Object.assign({}, relatedStart),\n            end: Object.assign({}, relatedEnd)\n        };\n        map.add(range[2], 0, [\n            [\n                \"enter\",\n                valueToken,\n                context\n            ]\n        ]);\n        (0,uvu_assert__WEBPACK_IMPORTED_MODULE_0__.ok)(range[3] !== 0);\n        if (rowKind !== 2) {\n            // Fix positional info on remaining events\n            const start = context.events[range[2]];\n            const end = context.events[range[3]];\n            start[1].end = Object.assign({}, end[1].end);\n            start[1].type = micromark_util_symbol_types_js__WEBPACK_IMPORTED_MODULE_1__.types.chunkText;\n            start[1].contentType = micromark_util_symbol_constants_js__WEBPACK_IMPORTED_MODULE_5__.constants.contentTypeText;\n            // Remove if needed.\n            if (range[3] > range[2] + 1) {\n                const a = range[2] + 1;\n                const b = range[3] - range[2] - 1;\n                map.add(a, b, []);\n            }\n        }\n        map.add(range[3] + 1, 0, [\n            [\n                \"exit\",\n                valueToken,\n                context\n            ]\n        ]);\n    }\n    // Insert an exit for the last cell, if at the row end.\n    //\n    // ```markdown\n    // > | | aa | bb | cc |\n    //                    ^-- exit\n    //               ^^^^^^-- this cell (the last one contains two “between” parts)\n    // ```\n    if (rowEnd !== undefined) {\n        previousCell.end = Object.assign({}, getPoint(context.events, rowEnd));\n        map.add(rowEnd, 0, [\n            [\n                \"exit\",\n                previousCell,\n                context\n            ]\n        ]);\n        previousCell = undefined;\n    }\n    return previousCell;\n}\n/**\n * Generate table end (and table body end).\n *\n * @param {EditMap} map\n * @param {TokenizeContext} context\n * @param {number} index\n * @param {Token} table\n * @param {Token | undefined} tableBody\n */ // eslint-disable-next-line max-params\nfunction flushTableEnd(map, context, index, table, tableBody) {\n    /** @type {Array<Event>} */ const exits = [];\n    const related = getPoint(context.events, index);\n    if (tableBody) {\n        tableBody.end = Object.assign({}, related);\n        exits.push([\n            \"exit\",\n            tableBody,\n            context\n        ]);\n    }\n    table.end = Object.assign({}, related);\n    exits.push([\n        \"exit\",\n        table,\n        context\n    ]);\n    map.add(index + 1, 0, exits);\n}\n/**\n * @param {Array<Event>} events\n * @param {number} index\n * @returns {readonly Point}\n */ function getPoint(events, index) {\n    const event = events[index];\n    const side = event[0] === \"enter\" ? \"start\" : \"end\";\n    return event[1][side];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFibGUvZGV2L2xpYi9zeW50YXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7OztDQVNDLEdBRUQ7Ozs7OztDQU1DLEdBRXNDO0FBQ2E7QUFLbkI7QUFDbUI7QUFDUTtBQUNSO0FBQ2Y7QUFDRztBQUV4Qyx1Q0FBdUM7QUFFdkM7Ozs7O0NBS0MsR0FDTSxNQUFNVyxXQUFXO0lBQ3RCQyxNQUFNO1FBQUNDLE1BQU07WUFBQ0MsVUFBVUM7WUFBZUMsWUFBWUM7UUFBWTtJQUFDO0FBQ2xFLEVBQUM7QUFFRDs7O0NBR0MsR0FDRCxTQUFTRixjQUFjRyxPQUFPLEVBQUVsQixFQUFFLEVBQUVtQixHQUFHO0lBQ3JDLE1BQU1DLE9BQU8sSUFBSTtJQUNqQixJQUFJQyxPQUFPO0lBQ1gsSUFBSUMsUUFBUTtJQUNaLGdDQUFnQyxHQUNoQyxJQUFJQztJQUVKLE9BQU9DO0lBRVA7Ozs7Ozs7Ozs7Ozs7OztHQWVDLEdBQ0QsU0FBU0EsTUFBTUMsSUFBSTtRQUNqQixJQUFJQyxRQUFRTixLQUFLTyxNQUFNLENBQUNDLE1BQU0sR0FBRztRQUVqQyxNQUFPRixRQUFRLENBQUMsRUFBRztZQUNqQixNQUFNRyxPQUFPVCxLQUFLTyxNQUFNLENBQUNELE1BQU0sQ0FBQyxFQUFFLENBQUNHLElBQUk7WUFDdkMsSUFDRUEsU0FBU3JCLGlFQUFLQSxDQUFDc0IsVUFBVSxJQUN6Qiw4REFBOEQ7WUFDOURELFNBQVNyQixpRUFBS0EsQ0FBQ3VCLFVBQVUsRUFFekJMO2lCQUNHO1FBQ1A7UUFFQSxNQUFNTSxPQUFPTixRQUFRLENBQUMsSUFBSU4sS0FBS08sTUFBTSxDQUFDRCxNQUFNLENBQUMsRUFBRSxDQUFDRyxJQUFJLEdBQUc7UUFFdkQsTUFBTUksT0FDSkQsU0FBUyxlQUFlQSxTQUFTLGFBQWFFLGVBQWVDO1FBRS9ELDhCQUE4QjtRQUM5QixJQUFJRixTQUFTQyxnQkFBZ0JkLEtB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QztTQUFRO0lBQ3pDO0lBRUFrQyxNQUFNbEIsR0FBRyxHQUFHRixPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHc0I7SUFDOUJELE1BQU1FLElBQUksQ0FBQztRQUFDO1FBQVFKO1FBQU9sQztLQUFRO0lBRW5DVSxJQUFJTyxHQUFHLENBQUMvRCxRQUFRLEdBQUcsR0FBR2tGO0FBQ3hCO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNYLFNBQVN0RSxNQUFNLEVBQUVELEtBQUs7SUFDN0IsTUFBTXlELFFBQVF4RCxNQUFNLENBQUNELE1BQU07SUFDM0IsTUFBTXFGLE9BQU81QixLQUFLLENBQUMsRUFBRSxLQUFLLFVBQVUsVUFBVTtJQUM5QyxPQUFPQSxLQUFLLENBQUMsRUFBRSxDQUFDNEIsS0FBSztBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3YwIGNsb25lIHdpdGggY29waWxvdGtpdCwgbmV4dC5qcywgYW5kIG9wZW5haSBncHQ0Ly4vbm9kZV9tb2R1bGVzL21pY3JvbWFyay1leHRlbnNpb24tZ2ZtLXRhYmxlL2Rldi9saWIvc3ludGF4LmpzP2Y0MTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkV2ZW50fSBFdmVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5FeHRlbnNpb259IEV4dGVuc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Qb2ludH0gUG9pbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuUmVzb2x2ZXJ9IFJlc29sdmVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLlN0YXRlfSBTdGF0ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbn0gVG9rZW5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVDb250ZXh0fSBUb2tlbml6ZUNvbnRleHRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVyfSBUb2tlbml6ZXJcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXX0gUmFuZ2VcbiAqICAgQ2VsbCBpbmZvLlxuICpcbiAqIEB0eXBlZGVmIHswIHwgMSB8IDIgfCAzfSBSb3dLaW5kXG4gKiAgIFdoZXJlIHdlIGFyZTogYDFgIGZvciBoZWFkIHJvdywgYDJgIGZvciBkZWxpbWl0ZXIgcm93LCBgM2AgZm9yIGJvZHkgcm93LlxuICovXG5cbmltcG9ydCB7b2sgYXMgYXNzZXJ0fSBmcm9tICd1dnUvYXNzZXJ0J1xuaW1wb3J0IHtmYWN0b3J5U3BhY2V9IGZyb20gJ21pY3JvbWFyay1mYWN0b3J5LXNwYWNlJ1xuaW1wb3J0IHtcbiAgbWFya2Rvd25MaW5lRW5kaW5nLFxuICBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlLFxuICBtYXJrZG93blNwYWNlXG59IGZyb20gJ21pY3JvbWFyay11dGlsLWNoYXJhY3RlcidcbmltcG9ydCB7Y29kZXN9IGZyb20gJ21pY3JvbWFyay11dGlsLXN5bWJvbC9jb2Rlcy5qcydcbmltcG9ydCB7Y29uc3RhbnRzfSBmcm9tICdtaWNyb21hcmstdXRpbC1zeW1ib2wvY29uc3RhbnRzLmpzJ1xuaW1wb3J0IHt0eXBlc30gZnJvbSAnbWljcm9tYXJrLXV0aWwtc3ltYm9sL3R5cGVzLmpzJ1xuaW1wb3J0IHtFZGl0TWFwfSBmcm9tICcuL2VkaXQtbWFwLmpzJ1xuaW1wb3J0IHtnZm1UYWJsZUFsaWdufSBmcm9tICcuL2luZmVyLmpzJ1xuXG4vLyBUbyBkbzogbmV4dCBtYWpvcjogZXhwb3NlIGZ1bmN0aW9ucy5cblxuLyoqXG4gKiBFeHRlbnNpb24gZm9yIGBtaWNyb21hcmtgIHRoYXQgY2FuIGJlIHBhc3NlZCBpbiBgZXh0ZW5zaW9uc2AgdG8gZW5hYmxlIEdGTVxuICogdGFibGUgc3ludGF4LlxuICpcbiAqIEB0eXBlIHtFeHRlbnNpb259XG4gKi9cbmV4cG9ydCBjb25zdCBnZm1UYWJsZSA9IHtcbiAgZmxvdzoge251bGw6IHt0b2tlbml6ZTogdG9rZW5pemVUYWJsZSwgcmVzb2x2ZUFsbDogcmVzb2x2ZVRhYmxlfX1cbn1cblxuLyoqXG4gKiBAdGhpcyB7VG9rZW5pemVDb250ZXh0fVxuICogQHR5cGUge1Rva2VuaXplcn1cbiAqL1xuZnVuY3Rpb24gdG9rZW5pemVUYWJsZShlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIGxldCBzaXplID0gMFxuICBsZXQgc2l6ZUIgPSAwXG4gIC8qKiBAdHlwZSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gKi9cbiAgbGV0IHNlZW5cblxuICByZXR1cm4gc3RhcnRcblxuICAvKipcbiAgICogU3RhcnQgb2YgYSBHRk0gdGFibGUuXG4gICAqXG4gICAqIElmIHRoZXJlIGlzIGEgdmFsaWQgdGFibGUgcm93IG9yIHRhYmxlIGhlYWQgYmVmb3JlLCB0aGVuIHdlIHRyeSB0byBwYXJzZVxuICAgKiBhbm90aGVyIHJvdy5cbiAgICogT3RoZXJ3aXNlLCB3ZSB0cnkgdG8gcGFyc2UgYSBoZWFkLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgfCBhIHxcbiAgICogICAgIF5cbiAgICogICB8IHwgLSB8XG4gICAqID4gfCB8IGIgfFxuICAgKiAgICAgXlxuICAgKiBgYGBcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGxldCBpbmRleCA9IHNlbGYuZXZlbnRzLmxlbmd0aCAtIDFcblxuICAgIHdoaWxlIChpbmRleCA+IC0xKSB7XG4gICAgICBjb25zdCB0eXBlID0gc2VsZi5ldmVudHNbaW5kZXhdWzFdLnR5cGVcbiAgICAgIGlmIChcbiAgICAgICAgdHlwZSA9PT0gdHlwZXMubGluZUVuZGluZyB8fFxuICAgICAgICAvLyBOb3RlOiBtYXJrZG93bi1ycyB1c2VzIGB3aGl0ZXNwYWNlYCBpbnN0ZWFkIG9mIGBsaW5lUHJlZml4YFxuICAgICAgICB0eXBlID09PSB0eXBlcy5saW5lUHJlZml4XG4gICAgICApXG4gICAgICAgIGluZGV4LS1cbiAgICAgIGVsc2UgYnJlYWtcbiAgICB9XG5cbiAgICBjb25zdCB0YWlsID0gaW5kZXggPiAtMSA/IHNlbGYuZXZlbnRzW2luZGV4XVsxXS50eXBlIDogbnVsbFxuXG4gICAgY29uc3QgbmV4dCA9XG4gICAgICB0YWlsID09PSAndGFibGVIZWFkJyB8fCB0YWlsID09PSAndGFibGVSb3cnID8gYm9keVJvd1N0YXJ0IDogaGVhZFJvd0JlZm9yZVxuXG4gICAgLy8gRG9u4oCZdCBhbGxvdyBsYXp5IGJvZHkgcm93cy5cbiAgICBpZiAobmV4dCA9PT0gYm9keVJvd1N0YXJ0ICYmIHNlbGYucGFyc2VyLmxhenlbc2VsZi5ub3coKS5saW5lXSkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIHJldHVybiBuZXh0KGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogQmVmb3JlIHRhYmxlIGhlYWQgcm93LlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgfCBhIHxcbiAgICogICAgIF5cbiAgICogICB8IHwgLSB8XG4gICAqICAgfCB8IGIgfFxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gaGVhZFJvd0JlZm9yZShjb2RlKSB7XG4gICAgZWZmZWN0cy5lbnRlcigndGFibGVIZWFkJylcbiAgICBlZmZlY3RzLmVudGVyKCd0YWJsZVJvdycpXG4gICAgcmV0dXJuIGhlYWRSb3dTdGFydChjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEJlZm9yZSB0YWJsZSBoZWFkIHJvdywgYWZ0ZXIgd2hpdGVzcGFjZS5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IHwgYSB8XG4gICAqICAgICBeXG4gICAqICAgfCB8IC0gfFxuICAgKiAgIHwgfCBiIHxcbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGhlYWRSb3dTdGFydChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLnZlcnRpY2FsQmFyKSB7XG4gICAgICByZXR1cm4gaGVhZFJvd0JyZWFrKGNvZGUpXG4gICAgfVxuXG4gICAgLy8gVG8gZG86IG1pY3JvbWFyay1qcyBzaG91bGQgbGV0IHVzIHBhcnNlIG91ciBvd24gd2hpdGVzcGFjZSBpbiBleHRlbnNpb25zLFxuICAgIC8vIGxpa2UgYG1hcmtkb3duLXJzYDpcbiAgICAvL1xuICAgIC8vIGBgYGpzXG4gICAgLy8gLy8gNCsgc3BhY2VzLlxuICAgIC8vIGlmIChtYXJrZG93blNwYWNlKGNvZGUpKSB7XG4gICAgLy8gICByZXR1cm4gbm9rKGNvZGUpXG4gICAgLy8gfVxuICAgIC8vIGBgYFxuXG4gICAgc2VlbiA9IHRydWVcbiAgICAvLyBDb3VudCB0aGUgZmlyc3QgY2hhcmFjdGVyLCB0aGF0IGlzbuKAmXQgYSBwaXBlLCBkb3VibGUuXG4gICAgc2l6ZUIgKz0gMVxuICAgIHJldHVybiBoZWFkUm93QnJlYWsoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBdCBicmVhayBpbiB0YWJsZSBoZWFkIHJvdy5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IHwgYSB8XG4gICAqICAgICBeXG4gICAqICAgICAgIF5cbiAgICogICAgICAgICBeXG4gICAqICAgfCB8IC0gfFxuICAgKiAgIHwgfCBiIHxcbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGhlYWRSb3dCcmVhayhjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmVvZikge1xuICAgICAgLy8gTm90ZTogaW4gYG1hcmtkb3duLXJzYCwgd2UgbmVlZCB0byByZXNldCwgaW4gYG1pY3JvbWFyay1qc2Agd2UgZG9u4oCYdC5cbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICAvLyBJZiBhbnl0aGluZyBvdGhlciB0aGFuIG9uZSBwaXBlIChpZ25vcmluZyB3aGl0ZXNwYWNlKSB3YXMgdXNlZCwgaXTigJlzIGZpbmUuXG4gICAgICBpZiAoc2l6ZUIgPiAxKSB7XG4gICAgICAgIHNpemVCID0gMFxuICAgICAgICAvLyBUbyBkbzogY2hlY2sgaWYgdGhpcyB3b3Jrcy5cbiAgICAgICAgLy8gRmVlbCBmcmVlIHRvIGludGVycnVwdDpcbiAgICAgICAgc2VsZi5pbnRlcnJ1cHQgPSB0cnVlXG4gICAgICAgIGVmZmVjdHMuZXhpdCgndGFibGVSb3cnKVxuICAgICAgICBlZmZlY3RzLmVudGVyKHR5cGVzLmxpbmVFbmRpbmcpXG4gICAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgICBlZmZlY3RzLmV4aXQodHlwZXMubGluZUVuZGluZylcbiAgICAgICAgcmV0dXJuIGhlYWREZWxpbWl0ZXJTdGFydFxuICAgICAgfVxuXG4gICAgICAvLyBOb3RlOiBpbiBgbWFya2Rvd24tcnNgLCB3ZSBuZWVkIHRvIHJlc2V0LCBpbiBgbWljcm9tYXJrLWpzYCB3ZSBkb27igJh0LlxuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGlmIChtYXJrZG93blNwYWNlKGNvZGUpKSB7XG4gICAgICAvLyBUbyBkbzogY2hlY2sgaWYgdGhpcyBpcyBmaW5lLlxuICAgICAgLy8gZWZmZWN0cy5hdHRlbXB0KFN0YXRlOjpOZXh0KFN0YXRlTmFtZTo6R2ZtVGFibGVIZWFkUm93QnJlYWspLCBTdGF0ZTo6Tm9rKVxuICAgICAgLy8gU3RhdGU6OlJldHJ5KHNwYWNlX29yX3RhYih0b2tlbml6ZXIpKVxuICAgICAgcmV0dXJuIGZhY3RvcnlTcGFjZShlZmZlY3RzLCBoZWFkUm93QnJlYWssIHR5cGVzLndoaXRlc3BhY2UpKGNvZGUpXG4gICAgfVxuXG4gICAgc2l6ZUIgKz0gMVxuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIHNlZW4gPSBmYWxzZVxuICAgICAgLy8gSGVhZGVyIGNlbGwgY291bnQuXG4gICAgICBzaXplICs9IDFcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gY29kZXMudmVydGljYWxCYXIpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlQ2VsbERpdmlkZXInKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlQ2VsbERpdmlkZXInKVxuICAgICAgLy8gV2hldGhlciBhIGRlbGltaXRlciB3YXMgc2Vlbi5cbiAgICAgIHNlZW4gPSB0cnVlXG4gICAgICByZXR1cm4gaGVhZFJvd0JyZWFrXG4gICAgfVxuXG4gICAgLy8gQW55dGhpbmcgZWxzZSBpcyBjZWxsIGRhdGEuXG4gICAgZWZmZWN0cy5lbnRlcih0eXBlcy5kYXRhKVxuICAgIHJldHVybiBoZWFkUm93RGF0YShjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEluIHRhYmxlIGhlYWQgcm93IGRhdGEuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCB8IGEgfFxuICAgKiAgICAgICBeXG4gICAqICAgfCB8IC0gfFxuICAgKiAgIHwgfCBiIHxcbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGhlYWRSb3dEYXRhKGNvZGUpIHtcbiAgICBpZiAoXG4gICAgICBjb2RlID09PSBjb2Rlcy5lb2YgfHxcbiAgICAgIGNvZGUgPT09IGNvZGVzLnZlcnRpY2FsQmFyIHx8XG4gICAgICBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpXG4gICAgKSB7XG4gICAgICBlZmZlY3RzLmV4aXQodHlwZXMuZGF0YSlcbiAgICAgIHJldHVybiBoZWFkUm93QnJlYWsoY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gY29kZSA9PT0gY29kZXMuYmFja3NsYXNoID8gaGVhZFJvd0VzY2FwZSA6IGhlYWRSb3dEYXRhXG4gIH1cblxuICAvKipcbiAgICogSW4gdGFibGUgaGVhZCByb3cgZXNjYXBlLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgfCBhXFwtYiB8XG4gICAqICAgICAgICAgXlxuICAgKiAgIHwgfCAtLS0tIHxcbiAgICogICB8IHwgYyAgICB8XG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBoZWFkUm93RXNjYXBlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gY29kZXMuYmFja3NsYXNoIHx8IGNvZGUgPT09IGNvZGVzLnZlcnRpY2FsQmFyKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBoZWFkUm93RGF0YVxuICAgIH1cblxuICAgIHJldHVybiBoZWFkUm93RGF0YShjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEJlZm9yZSBkZWxpbWl0ZXIgcm93LlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiAgIHwgfCBhIHxcbiAgICogPiB8IHwgLSB8XG4gICAqICAgICBeXG4gICAqICAgfCB8IGIgfFxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gaGVhZERlbGltaXRlclN0YXJ0KGNvZGUpIHtcbiAgICAvLyBSZXNldCBgaW50ZXJydXB0YC5cbiAgICBzZWxmLmludGVycnVwdCA9IGZhbHNlXG5cbiAgICAvLyBOb3RlOiBpbiBgbWFya2Rvd24tcnNgLCB3ZSBuZWVkIHRvIGhhbmRsZSBwaWVyY2luZyBoZXJlIHRvby5cbiAgICBpZiAoc2VsZi5wYXJzZXIubGF6eVtzZWxmLm5vdygpLmxpbmVdKSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5lbnRlcigndGFibGVEZWxpbWl0ZXJSb3cnKVxuICAgIC8vIFRyYWNrIGlmIHdl4oCZdmUgc2VlbiBhIGA6YCBvciBgfGAuXG4gICAgc2VlbiA9IGZhbHNlXG5cbiAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgYXNzZXJ0KHNlbGYucGFyc2VyLmNvbnN0cnVjdHMuZGlzYWJsZS5udWxsLCAnZXhwZWN0ZWQgYGRpc2FibGVkLm51bGxgJylcbiAgICAgIHJldHVybiBmYWN0b3J5U3BhY2UoXG4gICAgICAgIGVmZmVjdHMsXG4gICAgICAgIGhlYWREZWxpbWl0ZXJCZWZvcmUsXG4gICAgICAgIHR5cGVzLmxpbmVQcmVmaXgsXG4gICAgICAgIHNlbGYucGFyc2VyLmNvbnN0cnVjdHMuZGlzYWJsZS5udWxsLmluY2x1ZGVzKCdjb2RlSW5kZW50ZWQnKVxuICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgOiBjb25zdGFudHMudGFiU2l6ZVxuICAgICAgKShjb2RlKVxuICAgIH1cblxuICAgIHJldHVybiBoZWFkRGVsaW1pdGVyQmVmb3JlKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogQmVmb3JlIGRlbGltaXRlciByb3csIGFmdGVyIG9wdGlvbmFsIHdoaXRlc3BhY2UuXG4gICAqXG4gICAqIFJldXNlZCB3aGVuIGEgYHxgIGlzIGZvdW5kIGxhdGVyLCB0byBwYXJzZSBhbm90aGVyIGNlbGwuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqICAgfCB8IGEgfFxuICAgKiA+IHwgfCAtIHxcbiAgICogICAgIF5cbiAgICogICB8IHwgYiB8XG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBoZWFkRGVsaW1pdGVyQmVmb3JlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gY29kZXMuZGFzaCB8fCBjb2RlID09PSBjb2Rlcy5jb2xvbikge1xuICAgICAgcmV0dXJuIGhlYWREZWxpbWl0ZXJWYWx1ZUJlZm9yZShjb2RlKVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBjb2Rlcy52ZXJ0aWNhbEJhcikge1xuICAgICAgc2VlbiA9IHRydWVcbiAgICAgIC8vIElmIHdlIHN0YXJ0IHdpdGggYSBwaXBlLCB3ZSBvcGVuIGEgY2VsbCBtYXJrZXIuXG4gICAgICBlZmZlY3RzLmVudGVyKCd0YWJsZUNlbGxEaXZpZGVyJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCd0YWJsZUNlbGxEaXZpZGVyJylcbiAgICAgIHJldHVybiBoZWFkRGVsaW1pdGVyQ2VsbEJlZm9yZVxuICAgIH1cblxuICAgIC8vIE1vcmUgd2hpdGVzcGFjZSAvIGVtcHR5IHJvdyBub3QgYWxsb3dlZCBhdCBzdGFydC5cbiAgICByZXR1cm4gaGVhZERlbGltaXRlck5vayhjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEFmdGVyIGB8YCwgYmVmb3JlIGRlbGltaXRlciBjZWxsLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiAgIHwgfCBhIHxcbiAgICogPiB8IHwgLSB8XG4gICAqICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gaGVhZERlbGltaXRlckNlbGxCZWZvcmUoY29kZSkge1xuICAgIGlmIChtYXJrZG93blNwYWNlKGNvZGUpKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeVNwYWNlKFxuICAgICAgICBlZmZlY3RzLFxuICAgICAgICBoZWFkRGVsaW1pdGVyVmFsdWVCZWZvcmUsXG4gICAgICAgIHR5cGVzLndoaXRlc3BhY2VcbiAgICAgICkoY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZERlbGltaXRlclZhbHVlQmVmb3JlKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogQmVmb3JlIGRlbGltaXRlciBjZWxsIHZhbHVlLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiAgIHwgfCBhIHxcbiAgICogPiB8IHwgLSB8XG4gICAqICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGhlYWREZWxpbWl0ZXJWYWx1ZUJlZm9yZShjb2RlKSB7XG4gICAgLy8gQWxpZ246IGxlZnQuXG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmNvbG9uKSB7XG4gICAgICBzaXplQiArPSAxXG4gICAgICBzZWVuID0gdHJ1ZVxuXG4gICAgICBlZmZlY3RzLmVudGVyKCd0YWJsZURlbGltaXRlck1hcmtlcicpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgndGFibGVEZWxpbWl0ZXJNYXJrZXInKVxuICAgICAgcmV0dXJuIGhlYWREZWxpbWl0ZXJMZWZ0QWxpZ25tZW50QWZ0ZXJcbiAgICB9XG5cbiAgICAvLyBBbGlnbjogbm9uZS5cbiAgICBpZiAoY29kZSA9PT0gY29kZXMuZGFzaCkge1xuICAgICAgc2l6ZUIgKz0gMVxuICAgICAgLy8gVG8gZG86IHNlZW1zIHdlaXJkIHRoYXQgdGhpcyAqaXNu4oCZdCogbGVmdCBhbGlnbmVkLCBidXQgdGhhdCBzdGF0ZSBpcyB1c2VkP1xuICAgICAgcmV0dXJuIGhlYWREZWxpbWl0ZXJMZWZ0QWxpZ25tZW50QWZ0ZXIoY29kZSlcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gY29kZXMuZW9mIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgcmV0dXJuIGhlYWREZWxpbWl0ZXJDZWxsQWZ0ZXIoY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZERlbGltaXRlck5vayhjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEFmdGVyIGRlbGltaXRlciBjZWxsIGxlZnQgYWxpZ25tZW50IG1hcmtlci5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogICB8IHwgYSAgfFxuICAgKiA+IHwgfCA6LSB8XG4gICAqICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBoZWFkRGVsaW1pdGVyTGVmdEFsaWdubWVudEFmdGVyKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gY29kZXMuZGFzaCkge1xuICAgICAgZWZmZWN0cy5lbnRlcigndGFibGVEZWxpbWl0ZXJGaWxsZXInKVxuICAgICAgcmV0dXJuIGhlYWREZWxpbWl0ZXJGaWxsZXIoY29kZSlcbiAgICB9XG5cbiAgICAvLyBBbnl0aGluZyBlbHNlIGlzIG5vdCBvayBhZnRlciB0aGUgbGVmdC1hbGlnbiBjb2xvbi5cbiAgICByZXR1cm4gaGVhZERlbGltaXRlck5vayhjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEluIGRlbGltaXRlciBjZWxsIGZpbGxlci5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogICB8IHwgYSB8XG4gICAqID4gfCB8IC0gfFxuICAgKiAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBoZWFkRGVsaW1pdGVyRmlsbGVyKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gY29kZXMuZGFzaCkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gaGVhZERlbGltaXRlckZpbGxlclxuICAgIH1cblxuICAgIC8vIEFsaWduIGlzIGBjZW50ZXJgIGlmIGl0IHdhcyBgbGVmdGAsIGByaWdodGAgb3RoZXJ3aXNlLlxuICAgIGlmIChjb2RlID09PSBjb2Rlcy5jb2xvbikge1xuICAgICAgc2VlbiA9IHRydWVcbiAgICAgIGVmZmVjdHMuZXhpdCgndGFibGVEZWxpbWl0ZXJGaWxsZXInKVxuICAgICAgZWZmZWN0cy5lbnRlcigndGFibGVEZWxpbWl0ZXJNYXJrZXInKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlRGVsaW1pdGVyTWFya2VyJylcbiAgICAgIHJldHVybiBoZWFkRGVsaW1pdGVyUmlnaHRBbGlnbm1lbnRBZnRlclxuICAgIH1cblxuICAgIGVmZmVjdHMuZXhpdCgndGFibGVEZWxpbWl0ZXJGaWxsZXInKVxuICAgIHJldHVybiBoZWFkRGVsaW1pdGVyUmlnaHRBbGlnbm1lbnRBZnRlcihjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEFmdGVyIGRlbGltaXRlciBjZWxsIHJpZ2h0IGFsaWdubWVudCBtYXJrZXIuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqICAgfCB8ICBhIHxcbiAgICogPiB8IHwgLTogfFxuICAgKiAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGhlYWREZWxpbWl0ZXJSaWdodEFsaWdubWVudEFmdGVyKGNvZGUpIHtcbiAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgcmV0dXJuIGZhY3RvcnlTcGFjZShcbiAgICAgICAgZWZmZWN0cyxcbiAgICAgICAgaGVhZERlbGltaXRlckNlbGxBZnRlcixcbiAgICAgICAgdHlwZXMud2hpdGVzcGFjZVxuICAgICAgKShjb2RlKVxuICAgIH1cblxuICAgIHJldHVybiBoZWFkRGVsaW1pdGVyQ2VsbEFmdGVyKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogQWZ0ZXIgZGVsaW1pdGVyIGNlbGwuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqICAgfCB8ICBhIHxcbiAgICogPiB8IHwgLTogfFxuICAgKiAgICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBoZWFkRGVsaW1pdGVyQ2VsbEFmdGVyKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gY29kZXMudmVydGljYWxCYXIpIHtcbiAgICAgIHJldHVybiBoZWFkRGVsaW1pdGVyQmVmb3JlKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmVvZiB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIC8vIEV4aXQgd2hlbjpcbiAgICAgIC8vICogdGhlcmUgd2FzIG5vIGA6YCBvciBgfGAgYXQgYWxsIChpdOKAmXMgYSB0aGVtYXRpYyBicmVhayBvciBzZXRleHRcbiAgICAgIC8vICAgdW5kZXJsaW5lIGluc3RlYWQpXG4gICAgICAvLyAqIHRoZSBoZWFkZXIgY2VsbCBjb3VudCBpcyBub3QgdGhlIGRlbGltaXRlciBjZWxsIGNvdW50XG4gICAgICBpZiAoIXNlZW4gfHwgc2l6ZSAhPT0gc2l6ZUIpIHtcbiAgICAgICAgcmV0dXJuIGhlYWREZWxpbWl0ZXJOb2soY29kZSlcbiAgICAgIH1cblxuICAgICAgLy8gTm90ZTogaW4gbWFya2Rvd24tcnNgLCBhIHJlc2V0IGlzIG5lZWRlZCBoZXJlLlxuICAgICAgZWZmZWN0cy5leGl0KCd0YWJsZURlbGltaXRlclJvdycpXG4gICAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlSGVhZCcpXG4gICAgICAvLyBUbyBkbzogaW4gYG1hcmtkb3duLXJzYCwgcmVzb2x2ZXJzIG5lZWQgdG8gYmUgcmVnaXN0ZXJlZCBtYW51YWxseS5cbiAgICAgIC8vIGVmZmVjdHMucmVnaXN0ZXJfcmVzb2x2ZXIoUmVzb2x2ZU5hbWU6OkdmbVRhYmxlKVxuICAgICAgcmV0dXJuIG9rKGNvZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIGhlYWREZWxpbWl0ZXJOb2soY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiBkZWxpbWl0ZXIgcm93LCBhdCBhIGRpc2FsbG93ZWQgYnl0ZS5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogICB8IHwgYSB8XG4gICAqID4gfCB8IHggfFxuICAgKiAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBoZWFkRGVsaW1pdGVyTm9rKGNvZGUpIHtcbiAgICAvLyBOb3RlOiBpbiBgbWFya2Rvd24tcnNgLCB3ZSBuZWVkIHRvIHJlc2V0LCBpbiBgbWljcm9tYXJrLWpzYCB3ZSBkb27igJh0LlxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBCZWZvcmUgdGFibGUgYm9keSByb3cuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqICAgfCB8IGEgfFxuICAgKiAgIHwgfCAtIHxcbiAgICogPiB8IHwgYiB8XG4gICAqICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBib2R5Um93U3RhcnQoY29kZSkge1xuICAgIC8vIE5vdGU6IGluIGBtYXJrZG93bi1yc2Agd2UgbmVlZCB0byBtYW51YWxseSB0YWtlIGNhcmUgb2YgYSBwcmVmaXgsXG4gICAgLy8gYnV0IGluIGBtaWNyb21hcmstanNgIHRoYXQgaXMgZG9uZSBmb3IgdXMsIHNvIGlmIHdl4oCZcmUgaGVyZSwgd2XigJlyZVxuICAgIC8vIG5ldmVyIGF0IHdoaXRlc3BhY2UuXG4gICAgZWZmZWN0cy5lbnRlcigndGFibGVSb3cnKVxuICAgIHJldHVybiBib2R5Um93QnJlYWsoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBdCBicmVhayBpbiB0YWJsZSBib2R5IHJvdy5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogICB8IHwgYSB8XG4gICAqICAgfCB8IC0gfFxuICAgKiA+IHwgfCBiIHxcbiAgICogICAgIF5cbiAgICogICAgICAgXlxuICAgKiAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGJvZHlSb3dCcmVhayhjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLnZlcnRpY2FsQmFyKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCd0YWJsZUNlbGxEaXZpZGVyJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCd0YWJsZUNlbGxEaXZpZGVyJylcbiAgICAgIHJldHVybiBib2R5Um93QnJlYWtcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gY29kZXMuZW9mIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgZWZmZWN0cy5leGl0KCd0YWJsZVJvdycpXG4gICAgICByZXR1cm4gb2soY29kZSlcbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgcmV0dXJuIGZhY3RvcnlTcGFjZShlZmZlY3RzLCBib2R5Um93QnJlYWssIHR5cGVzLndoaXRlc3BhY2UpKGNvZGUpXG4gICAgfVxuXG4gICAgLy8gQW55dGhpbmcgZWxzZSBpcyBjZWxsIGNvbnRlbnQuXG4gICAgZWZmZWN0cy5lbnRlcih0eXBlcy5kYXRhKVxuICAgIHJldHVybiBib2R5Um93RGF0YShjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEluIHRhYmxlIGJvZHkgcm93IGRhdGEuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqICAgfCB8IGEgfFxuICAgKiAgIHwgfCAtIHxcbiAgICogPiB8IHwgYiB8XG4gICAqICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGJvZHlSb3dEYXRhKGNvZGUpIHtcbiAgICBpZiAoXG4gICAgICBjb2RlID09PSBjb2Rlcy5lb2YgfHxcbiAgICAgIGNvZGUgPT09IGNvZGVzLnZlcnRpY2FsQmFyIHx8XG4gICAgICBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpXG4gICAgKSB7XG4gICAgICBlZmZlY3RzLmV4aXQodHlwZXMuZGF0YSlcbiAgICAgIHJldHVybiBib2R5Um93QnJlYWsoY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gY29kZSA9PT0gY29kZXMuYmFja3NsYXNoID8gYm9keVJvd0VzY2FwZSA6IGJvZHlSb3dEYXRhXG4gIH1cblxuICAvKipcbiAgICogSW4gdGFibGUgYm9keSByb3cgZXNjYXBlLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiAgIHwgfCBhICAgIHxcbiAgICogICB8IHwgLS0tLSB8XG4gICAqID4gfCB8IGJcXC1jIHxcbiAgICogICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBib2R5Um93RXNjYXBlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gY29kZXMuYmFja3NsYXNoIHx8IGNvZGUgPT09IGNvZGVzLnZlcnRpY2FsQmFyKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBib2R5Um93RGF0YVxuICAgIH1cblxuICAgIHJldHVybiBib2R5Um93RGF0YShjb2RlKVxuICB9XG59XG5cbi8qKiBAdHlwZSB7UmVzb2x2ZXJ9ICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gcmVzb2x2ZVRhYmxlKGV2ZW50cywgY29udGV4dCkge1xuICBsZXQgaW5kZXggPSAtMVxuICBsZXQgaW5GaXJzdENlbGxBd2FpdGluZ1BpcGUgPSB0cnVlXG4gIC8qKiBAdHlwZSB7Um93S2luZH0gKi9cbiAgbGV0IHJvd0tpbmQgPSAwXG4gIC8qKiBAdHlwZSB7UmFuZ2V9ICovXG4gIGxldCBsYXN0Q2VsbCA9IFswLCAwLCAwLCAwXVxuICAvKiogQHR5cGUge1JhbmdlfSAqL1xuICBsZXQgY2VsbCA9IFswLCAwLCAwLCAwXVxuICBsZXQgYWZ0ZXJIZWFkQXdhaXRpbmdGaXJzdEJvZHlSb3cgPSBmYWxzZVxuICBsZXQgbGFzdFRhYmxlRW5kID0gMFxuICAvKiogQHR5cGUge1Rva2VuIHwgdW5kZWZpbmVkfSAqL1xuICBsZXQgY3VycmVudFRhYmxlXG4gIC8qKiBAdHlwZSB7VG9rZW4gfCB1bmRlZmluZWR9ICovXG4gIGxldCBjdXJyZW50Qm9keVxuICAvKiogQHR5cGUge1Rva2VuIHwgdW5kZWZpbmVkfSAqL1xuICBsZXQgY3VycmVudENlbGxcblxuICBjb25zdCBtYXAgPSBuZXcgRWRpdE1hcCgpXG5cbiAgd2hpbGUgKCsraW5kZXggPCBldmVudHMubGVuZ3RoKSB7XG4gICAgY29uc3QgZXZlbnQgPSBldmVudHNbaW5kZXhdXG4gICAgY29uc3QgdG9rZW4gPSBldmVudFsxXVxuXG4gICAgaWYgKGV2ZW50WzBdID09PSAnZW50ZXInKSB7XG4gICAgICAvLyBTdGFydCBvZiBoZWFkLlxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICd0YWJsZUhlYWQnKSB7XG4gICAgICAgIGFmdGVySGVhZEF3YWl0aW5nRmlyc3RCb2R5Um93ID0gZmFsc2VcblxuICAgICAgICAvLyBJbmplY3QgcHJldmlvdXMgKGJvZHkgZW5kIGFuZCkgdGFibGUgZW5kLlxuICAgICAgICBpZiAobGFzdFRhYmxlRW5kICE9PSAwKSB7XG4gICAgICAgICAgYXNzZXJ0KGN1cnJlbnRUYWJsZSwgJ3RoZXJlIHNob3VsZCBiZSBhIHRhYmxlIG9wZW5pbmcnKVxuICAgICAgICAgIGZsdXNoVGFibGVFbmQobWFwLCBjb250ZXh0LCBsYXN0VGFibGVFbmQsIGN1cnJlbnRUYWJsZSwgY3VycmVudEJvZHkpXG4gICAgICAgICAgY3VycmVudEJvZHkgPSB1bmRlZmluZWRcbiAgICAgICAgICBsYXN0VGFibGVFbmQgPSAwXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbmplY3QgdGFibGUgc3RhcnQuXG4gICAgICAgIGN1cnJlbnRUYWJsZSA9IHtcbiAgICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICAgIHN0YXJ0OiBPYmplY3QuYXNzaWduKHt9LCB0b2tlbi5zdGFydCksXG4gICAgICAgICAgLy8gTm90ZTogY29ycmVjdCBlbmQgaXMgc2V0IGxhdGVyLlxuICAgICAgICAgIGVuZDogT2JqZWN0LmFzc2lnbih7fSwgdG9rZW4uZW5kKVxuICAgICAgICB9XG4gICAgICAgIG1hcC5hZGQoaW5kZXgsIDAsIFtbJ2VudGVyJywgY3VycmVudFRhYmxlLCBjb250ZXh0XV0pXG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICB0b2tlbi50eXBlID09PSAndGFibGVSb3cnIHx8XG4gICAgICAgIHRva2VuLnR5cGUgPT09ICd0YWJsZURlbGltaXRlclJvdydcbiAgICAgICkge1xuICAgICAgICBpbkZpcnN0Q2VsbEF3YWl0aW5nUGlwZSA9IHRydWVcbiAgICAgICAgY3VycmVudENlbGwgPSB1bmRlZmluZWRcbiAgICAgICAgbGFzdENlbGwgPSBbMCwgMCwgMCwgMF1cbiAgICAgICAgY2VsbCA9IFswLCBpbmRleCArIDEsIDAsIDBdXG5cbiAgICAgICAgLy8gSW5qZWN0IHRhYmxlIGJvZHkgc3RhcnQuXG4gICAgICAgIGlmIChhZnRlckhlYWRBd2FpdGluZ0ZpcnN0Qm9keVJvdykge1xuICAgICAgICAgIGFmdGVySGVhZEF3YWl0aW5nRmlyc3RCb2R5Um93ID0gZmFsc2VcbiAgICAgICAgICBjdXJyZW50Qm9keSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICd0YWJsZUJvZHknLFxuICAgICAgICAgICAgc3RhcnQ6IE9iamVjdC5hc3NpZ24oe30sIHRva2VuLnN0YXJ0KSxcbiAgICAgICAgICAgIC8vIE5vdGU6IGNvcnJlY3QgZW5kIGlzIHNldCBsYXRlci5cbiAgICAgICAgICAgIGVuZDogT2JqZWN0LmFzc2lnbih7fSwgdG9rZW4uZW5kKVxuICAgICAgICAgIH1cbiAgICAgICAgICBtYXAuYWRkKGluZGV4LCAwLCBbWydlbnRlcicsIGN1cnJlbnRCb2R5LCBjb250ZXh0XV0pXG4gICAgICAgIH1cblxuICAgICAgICByb3dLaW5kID0gdG9rZW4udHlwZSA9PT0gJ3RhYmxlRGVsaW1pdGVyUm93JyA/IDIgOiBjdXJyZW50Qm9keSA/IDMgOiAxXG4gICAgICB9XG4gICAgICAvLyBDZWxsIGRhdGEuXG4gICAgICBlbHNlIGlmIChcbiAgICAgICAgcm93S2luZCAmJlxuICAgICAgICAodG9rZW4udHlwZSA9PT0gdHlwZXMuZGF0YSB8fFxuICAgICAgICAgIHRva2VuLnR5cGUgPT09ICd0YWJsZURlbGltaXRlck1hcmtlcicgfHxcbiAgICAgICAgICB0b2tlbi50eXBlID09PSAndGFibGVEZWxpbWl0ZXJGaWxsZXInKVxuICAgICAgKSB7XG4gICAgICAgIGluRmlyc3RDZWxsQXdhaXRpbmdQaXBlID0gZmFsc2VcblxuICAgICAgICAvLyBGaXJzdCB2YWx1ZSBpbiBjZWxsLlxuICAgICAgICBpZiAoY2VsbFsyXSA9PT0gMCkge1xuICAgICAgICAgIGlmIChsYXN0Q2VsbFsxXSAhPT0gMCkge1xuICAgICAgICAgICAgY2VsbFswXSA9IGNlbGxbMV1cbiAgICAgICAgICAgIGN1cnJlbnRDZWxsID0gZmx1c2hDZWxsKFxuICAgICAgICAgICAgICBtYXAsXG4gICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgIGxhc3RDZWxsLFxuICAgICAgICAgICAgICByb3dLaW5kLFxuICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIGN1cnJlbnRDZWxsXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBsYXN0Q2VsbCA9IFswLCAwLCAwLCAwXVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNlbGxbMl0gPSBpbmRleFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRva2VuLnR5cGUgPT09ICd0YWJsZUNlbGxEaXZpZGVyJykge1xuICAgICAgICBpZiAoaW5GaXJzdENlbGxBd2FpdGluZ1BpcGUpIHtcbiAgICAgICAgICBpbkZpcnN0Q2VsbEF3YWl0aW5nUGlwZSA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGxhc3RDZWxsWzFdICE9PSAwKSB7XG4gICAgICAgICAgICBjZWxsWzBdID0gY2VsbFsxXVxuICAgICAgICAgICAgY3VycmVudENlbGwgPSBmbHVzaENlbGwoXG4gICAgICAgICAgICAgIG1hcCxcbiAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgbGFzdENlbGwsXG4gICAgICAgICAgICAgIHJvd0tpbmQsXG4gICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgY3VycmVudENlbGxcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsYXN0Q2VsbCA9IGNlbGxcbiAgICAgICAgICBjZWxsID0gW2xhc3RDZWxsWzFdLCBpbmRleCwgMCwgMF1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBFeGl0IGV2ZW50cy5cbiAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSAndGFibGVIZWFkJykge1xuICAgICAgYWZ0ZXJIZWFkQXdhaXRpbmdGaXJzdEJvZHlSb3cgPSB0cnVlXG4gICAgICBsYXN0VGFibGVFbmQgPSBpbmRleFxuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0b2tlbi50eXBlID09PSAndGFibGVSb3cnIHx8XG4gICAgICB0b2tlbi50eXBlID09PSAndGFibGVEZWxpbWl0ZXJSb3cnXG4gICAgKSB7XG4gICAgICBsYXN0VGFibGVFbmQgPSBpbmRleFxuXG4gICAgICBpZiAobGFzdENlbGxbMV0gIT09IDApIHtcbiAgICAgICAgY2VsbFswXSA9IGNlbGxbMV1cbiAgICAgICAgY3VycmVudENlbGwgPSBmbHVzaENlbGwoXG4gICAgICAgICAgbWFwLFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgbGFzdENlbGwsXG4gICAgICAgICAgcm93S2luZCxcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBjdXJyZW50Q2VsbFxuICAgICAgICApXG4gICAgICB9IGVsc2UgaWYgKGNlbGxbMV0gIT09IDApIHtcbiAgICAgICAgY3VycmVudENlbGwgPSBmbHVzaENlbGwobWFwLCBjb250ZXh0LCBjZWxsLCByb3dLaW5kLCBpbmRleCwgY3VycmVudENlbGwpXG4gICAgICB9XG5cbiAgICAgIHJvd0tpbmQgPSAwXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHJvd0tpbmQgJiZcbiAgICAgICh0b2tlbi50eXBlID09PSB0eXBlcy5kYXRhIHx8XG4gICAgICAgIHRva2VuLnR5cGUgPT09ICd0YWJsZURlbGltaXRlck1hcmtlcicgfHxcbiAgICAgICAgdG9rZW4udHlwZSA9PT0gJ3RhYmxlRGVsaW1pdGVyRmlsbGVyJylcbiAgICApIHtcbiAgICAgIGNlbGxbM10gPSBpbmRleFxuICAgIH1cbiAgfVxuXG4gIGlmIChsYXN0VGFibGVFbmQgIT09IDApIHtcbiAgICBhc3NlcnQoY3VycmVudFRhYmxlLCAnZXhwZWN0ZWQgdGFibGUgb3BlbmluZycpXG4gICAgZmx1c2hUYWJsZUVuZChtYXAsIGNvbnRleHQsIGxhc3RUYWJsZUVuZCwgY3VycmVudFRhYmxlLCBjdXJyZW50Qm9keSlcbiAgfVxuXG4gIG1hcC5jb25zdW1lKGNvbnRleHQuZXZlbnRzKVxuXG4gIC8vIFRvIGRvOiBtb3ZlIHRoaXMgaW50byBgaHRtbGAsIHdoZW4gZXZlbnRzIGFyZSBleHBvc2VkIHRoZXJlLlxuICAvLyBUaGF04oCZcyB3aGF0IGBtYXJrZG93bi1yc2AgZG9lcy5cbiAgLy8gVGhhdCBuZWVkcyB1cGRhdGVzIHRvIGBtZGFzdC11dGlsLWdmbS10YWJsZWAuXG4gIGluZGV4ID0gLTFcbiAgd2hpbGUgKCsraW5kZXggPCBjb250ZXh0LmV2ZW50cy5sZW5ndGgpIHtcbiAgICBjb25zdCBldmVudCA9IGNvbnRleHQuZXZlbnRzW2luZGV4XVxuICAgIGlmIChldmVudFswXSA9PT0gJ2VudGVyJyAmJiBldmVudFsxXS50eXBlID09PSAndGFibGUnKSB7XG4gICAgICBldmVudFsxXS5fYWxpZ24gPSBnZm1UYWJsZUFsaWduKGNvbnRleHQuZXZlbnRzLCBpbmRleClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXZlbnRzXG59XG5cbi8vLyBHZW5lcmF0ZSBhIGNlbGwuXG4vKipcbiAqXG4gKiBAcGFyYW0ge0VkaXRNYXB9IG1hcFxuICogQHBhcmFtIHtUb2tlbml6ZUNvbnRleHR9IGNvbnRleHRcbiAqIEBwYXJhbSB7UmFuZ2V9IHJhbmdlXG4gKiBAcGFyYW0ge1Jvd0tpbmR9IHJvd0tpbmRcbiAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSByb3dFbmRcbiAqIEBwYXJhbSB7VG9rZW4gfCB1bmRlZmluZWR9IHByZXZpb3VzQ2VsbFxuICogQHJldHVybnMge1Rva2VuIHwgdW5kZWZpbmVkfVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xuZnVuY3Rpb24gZmx1c2hDZWxsKG1hcCwgY29udGV4dCwgcmFuZ2UsIHJvd0tpbmQsIHJvd0VuZCwgcHJldmlvdXNDZWxsKSB7XG4gIC8vIGBtYXJrZG93bi1yc2AgdXNlczpcbiAgLy8gcm93S2luZCA9PT0gMiA/ICd0YWJsZURlbGltaXRlckNlbGwnIDogJ3RhYmxlQ2VsbCdcbiAgY29uc3QgZ3JvdXBOYW1lID1cbiAgICByb3dLaW5kID09PSAxXG4gICAgICA/ICd0YWJsZUhlYWRlcidcbiAgICAgIDogcm93S2luZCA9PT0gMlxuICAgICAgPyAndGFibGVEZWxpbWl0ZXInXG4gICAgICA6ICd0YWJsZURhdGEnXG4gIC8vIGBtYXJrZG93bi1yc2AgdXNlczpcbiAgLy8gcm93S2luZCA9PT0gMiA/ICd0YWJsZURlbGltaXRlckNlbGxWYWx1ZScgOiAndGFibGVDZWxsVGV4dCdcbiAgY29uc3QgdmFsdWVOYW1lID0gJ3RhYmxlQ29udGVudCdcblxuICAvLyBJbnNlcnQgYW4gZXhpdCBmb3IgdGhlIHByZXZpb3VzIGNlbGwsIGlmIHRoZXJlIGlzIG9uZS5cbiAgLy9cbiAgLy8gYGBgbWFya2Rvd25cbiAgLy8gPiB8IHwgYWEgfCBiYiB8IGNjIHxcbiAgLy8gICAgICAgICAgXi0tIGV4aXRcbiAgLy8gICAgICAgICAgIF5eXl4tLSB0aGlzIGNlbGxcbiAgLy8gYGBgXG4gIGlmIChyYW5nZVswXSAhPT0gMCkge1xuICAgIGFzc2VydChwcmV2aW91c0NlbGwsICdleHBlY3RlZCBwcmV2aW91cyBjZWxsIGVudGVyJylcbiAgICBwcmV2aW91c0NlbGwuZW5kID0gT2JqZWN0LmFzc2lnbih7fSwgZ2V0UG9pbnQoY29udGV4dC5ldmVudHMsIHJhbmdlWzBdKSlcbiAgICBtYXAuYWRkKHJhbmdlWzBdLCAwLCBbWydleGl0JywgcHJldmlvdXNDZWxsLCBjb250ZXh0XV0pXG4gIH1cblxuICAvLyBJbnNlcnQgZW50ZXIgb2YgdGhpcyBjZWxsLlxuICAvL1xuICAvLyBgYGBtYXJrZG93blxuICAvLyA+IHwgfCBhYSB8IGJiIHwgY2MgfFxuICAvLyAgICAgICAgICAgXi0tIGVudGVyXG4gIC8vICAgICAgICAgICBeXl5eLS0gdGhpcyBjZWxsXG4gIC8vIGBgYFxuICBjb25zdCBub3cgPSBnZXRQb2ludChjb250ZXh0LmV2ZW50cywgcmFuZ2VbMV0pXG4gIHByZXZpb3VzQ2VsbCA9IHtcbiAgICB0eXBlOiBncm91cE5hbWUsXG4gICAgc3RhcnQ6IE9iamVjdC5hc3NpZ24oe30sIG5vdyksXG4gICAgLy8gTm90ZTogY29ycmVjdCBlbmQgaXMgc2V0IGxhdGVyLlxuICAgIGVuZDogT2JqZWN0LmFzc2lnbih7fSwgbm93KVxuICB9XG4gIG1hcC5hZGQocmFuZ2VbMV0sIDAsIFtbJ2VudGVyJywgcHJldmlvdXNDZWxsLCBjb250ZXh0XV0pXG5cbiAgLy8gSW5zZXJ0IHRleHQgc3RhcnQgYXQgZmlyc3QgZGF0YSBzdGFydCBhbmQgZW5kIGF0IGxhc3QgZGF0YSBlbmQsIGFuZFxuICAvLyByZW1vdmUgZXZlbnRzIGJldHdlZW4uXG4gIC8vXG4gIC8vIGBgYG1hcmtkb3duXG4gIC8vID4gfCB8IGFhIHwgYmIgfCBjYyB8XG4gIC8vICAgICAgICAgICAgXi0tIGVudGVyXG4gIC8vICAgICAgICAgICAgIF4tLSBleGl0XG4gIC8vICAgICAgICAgICBeXl5eLS0gdGhpcyBjZWxsXG4gIC8vIGBgYFxuICBpZiAocmFuZ2VbMl0gIT09IDApIHtcbiAgICBjb25zdCByZWxhdGVkU3RhcnQgPSBnZXRQb2ludChjb250ZXh0LmV2ZW50cywgcmFuZ2VbMl0pXG4gICAgY29uc3QgcmVsYXRlZEVuZCA9IGdldFBvaW50KGNvbnRleHQuZXZlbnRzLCByYW5nZVszXSlcbiAgICAvKiogQHR5cGUge1Rva2VufSAqL1xuICAgIGNvbnN0IHZhbHVlVG9rZW4gPSB7XG4gICAgICB0eXBlOiB2YWx1ZU5hbWUsXG4gICAgICBzdGFydDogT2JqZWN0LmFzc2lnbih7fSwgcmVsYXRlZFN0YXJ0KSxcbiAgICAgIGVuZDogT2JqZWN0LmFzc2lnbih7fSwgcmVsYXRlZEVuZClcbiAgICB9XG4gICAgbWFwLmFkZChyYW5nZVsyXSwgMCwgW1snZW50ZXInLCB2YWx1ZVRva2VuLCBjb250ZXh0XV0pXG4gICAgYXNzZXJ0KHJhbmdlWzNdICE9PSAwKVxuXG4gICAgaWYgKHJvd0tpbmQgIT09IDIpIHtcbiAgICAgIC8vIEZpeCBwb3NpdGlvbmFsIGluZm8gb24gcmVtYWluaW5nIGV2ZW50c1xuICAgICAgY29uc3Qgc3RhcnQgPSBjb250ZXh0LmV2ZW50c1tyYW5nZVsyXV1cbiAgICAgIGNvbnN0IGVuZCA9IGNvbnRleHQuZXZlbnRzW3JhbmdlWzNdXVxuICAgICAgc3RhcnRbMV0uZW5kID0gT2JqZWN0LmFzc2lnbih7fSwgZW5kWzFdLmVuZClcbiAgICAgIHN0YXJ0WzFdLnR5cGUgPSB0eXBlcy5jaHVua1RleHRcbiAgICAgIHN0YXJ0WzFdLmNvbnRlbnRUeXBlID0gY29uc3RhbnRzLmNvbnRlbnRUeXBlVGV4dFxuXG4gICAgICAvLyBSZW1vdmUgaWYgbmVlZGVkLlxuICAgICAgaWYgKHJhbmdlWzNdID4gcmFuZ2VbMl0gKyAxKSB7XG4gICAgICAgIGNvbnN0IGEgPSByYW5nZVsyXSArIDFcbiAgICAgICAgY29uc3QgYiA9IHJhbmdlWzNdIC0gcmFuZ2VbMl0gLSAxXG4gICAgICAgIG1hcC5hZGQoYSwgYiwgW10pXG4gICAgICB9XG4gICAgfVxuXG4gICAgbWFwLmFkZChyYW5nZVszXSArIDEsIDAsIFtbJ2V4aXQnLCB2YWx1ZVRva2VuLCBjb250ZXh0XV0pXG4gIH1cblxuICAvLyBJbnNlcnQgYW4gZXhpdCBmb3IgdGhlIGxhc3QgY2VsbCwgaWYgYXQgdGhlIHJvdyBlbmQuXG4gIC8vXG4gIC8vIGBgYG1hcmtkb3duXG4gIC8vID4gfCB8IGFhIHwgYmIgfCBjYyB8XG4gIC8vICAgICAgICAgICAgICAgICAgICBeLS0gZXhpdFxuICAvLyAgICAgICAgICAgICAgIF5eXl5eXi0tIHRoaXMgY2VsbCAodGhlIGxhc3Qgb25lIGNvbnRhaW5zIHR3byDigJxiZXR3ZWVu4oCdIHBhcnRzKVxuICAvLyBgYGBcbiAgaWYgKHJvd0VuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHJldmlvdXNDZWxsLmVuZCA9IE9iamVjdC5hc3NpZ24oe30sIGdldFBvaW50KGNvbnRleHQuZXZlbnRzLCByb3dFbmQpKVxuICAgIG1hcC5hZGQocm93RW5kLCAwLCBbWydleGl0JywgcHJldmlvdXNDZWxsLCBjb250ZXh0XV0pXG4gICAgcHJldmlvdXNDZWxsID0gdW5kZWZpbmVkXG4gIH1cblxuICByZXR1cm4gcHJldmlvdXNDZWxsXG59XG5cbi8qKlxuICogR2VuZXJhdGUgdGFibGUgZW5kIChhbmQgdGFibGUgYm9keSBlbmQpLlxuICpcbiAqIEBwYXJhbSB7RWRpdE1hcH0gbWFwXG4gKiBAcGFyYW0ge1Rva2VuaXplQ29udGV4dH0gY29udGV4dFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge1Rva2VufSB0YWJsZVxuICogQHBhcmFtIHtUb2tlbiB8IHVuZGVmaW5lZH0gdGFibGVCb2R5XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtcGFyYW1zXG5mdW5jdGlvbiBmbHVzaFRhYmxlRW5kKG1hcCwgY29udGV4dCwgaW5kZXgsIHRhYmxlLCB0YWJsZUJvZHkpIHtcbiAgLyoqIEB0eXBlIHtBcnJheTxFdmVudD59ICovXG4gIGNvbnN0IGV4aXRzID0gW11cbiAgY29uc3QgcmVsYXRlZCA9IGdldFBvaW50KGNvbnRleHQuZXZlbnRzLCBpbmRleClcblxuICBpZiAodGFibGVCb2R5KSB7XG4gICAgdGFibGVCb2R5LmVuZCA9IE9iamVjdC5hc3NpZ24oe30sIHJlbGF0ZWQpXG4gICAgZXhpdHMucHVzaChbJ2V4aXQnLCB0YWJsZUJvZHksIGNvbnRleHRdKVxuICB9XG5cbiAgdGFibGUuZW5kID0gT2JqZWN0LmFzc2lnbih7fSwgcmVsYXRlZClcbiAgZXhpdHMucHVzaChbJ2V4aXQnLCB0YWJsZSwgY29udGV4dF0pXG5cbiAgbWFwLmFkZChpbmRleCArIDEsIDAsIGV4aXRzKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8RXZlbnQ+fSBldmVudHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHJldHVybnMge3JlYWRvbmx5IFBvaW50fVxuICovXG5mdW5jdGlvbiBnZXRQb2ludChldmVudHMsIGluZGV4KSB7XG4gIGNvbnN0IGV2ZW50ID0gZXZlbnRzW2luZGV4XVxuICBjb25zdCBzaWRlID0gZXZlbnRbMF0gPT09ICdlbnRlcicgPyAnc3RhcnQnIDogJ2VuZCdcbiAgcmV0dXJuIGV2ZW50WzFdW3NpZGVdXG59XG4iXSwibmFtZXMiOlsib2siLCJhc3NlcnQiLCJmYWN0b3J5U3BhY2UiLCJtYXJrZG93bkxpbmVFbmRpbmciLCJtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlIiwibWFya2Rvd25TcGFjZSIsImNvZGVzIiwiY29uc3RhbnRzIiwidHlwZXMiLCJFZGl0TWFwIiwiZ2ZtVGFibGVBbGlnbiIsImdmbVRhYmxlIiwiZmxvdyIsIm51bGwiLCJ0b2tlbml6ZSIsInRva2VuaXplVGFibGUiLCJyZXNvbHZlQWxsIiwicmVzb2x2ZVRhYmxlIiwiZWZmZWN0cyIsIm5vayIsInNlbGYiLCJzaXplIiwic2l6ZUIiLCJzZWVuIiwic3RhcnQiLCJjb2RlIiwiaW5kZXgiLCJldmVudHMiLCJsZW5ndGgiLCJ0eXBlIiwibGluZUVuZGluZyIsImxpbmVQcmVmaXgiLCJ0YWlsIiwibmV4dCIsImJvZHlSb3dTdGFydCIsImhlYWRSb3dCZWZvcmUiLCJwYXJzZXIiLCJsYXp5Iiwibm93IiwibGluZSIsImVudGVyIiwiaGVhZFJvd1N0YXJ0IiwidmVydGljYWxCYXIiLCJoZWFkUm93QnJlYWsiLCJlb2YiLCJpbnRlcnJ1cHQiLCJleGl0IiwiY29uc3VtZSIsImhlYWREZWxpbWl0ZXJTdGFydCIsIndoaXRlc3BhY2UiLCJkYXRhIiwiaGVhZFJvd0RhdGEiLCJiYWNrc2xhc2giLCJoZWFkUm93RXNjYXBlIiwiY29uc3RydWN0cyIsImRpc2FibGUiLCJoZWFkRGVsaW1pdGVyQmVmb3JlIiwiaW5jbHVkZXMiLCJ1bmRlZmluZWQiLCJ0YWJTaXplIiwiZGFzaCIsImNvbG9uIiwiaGVhZERlbGltaXRlclZhbHVlQmVmb3JlIiwiaGVhZERlbGltaXRlckNlbGxCZWZvcmUiLCJoZWFkRGVsaW1pdGVyTm9rIiwiaGVhZERlbGltaXRlckxlZnRBbGlnbm1lbnRBZnRlciIsImhlYWREZWxpbWl0ZXJDZWxsQWZ0ZXIiLCJoZWFkRGVsaW1pdGVyRmlsbGVyIiwiaGVhZERlbGltaXRlclJpZ2h0QWxpZ25tZW50QWZ0ZXIiLCJib2R5Um93QnJlYWsiLCJib2R5Um93RGF0YSIsImJvZHlSb3dFc2NhcGUiLCJjb250ZXh0IiwiaW5GaXJzdENlbGxBd2FpdGluZ1BpcGUiLCJyb3dLaW5kIiwibGFzdENlbGwiLCJjZWxsIiwiYWZ0ZXJIZWFkQXdhaXRpbmdGaXJzdEJvZHlSb3ciLCJsYXN0VGFibGVFbmQiLCJjdXJyZW50VGFibGUiLCJjdXJyZW50Qm9keSIsImN1cnJlbnRDZWxsIiwibWFwIiwiZXZlbnQiLCJ0b2tlbiIsImZsdXNoVGFibGVFbmQiLCJPYmplY3QiLCJhc3NpZ24iLCJlbmQiLCJhZGQiLCJmbHVzaENlbGwiLCJfYWxpZ24iLCJyYW5nZSIsInJvd0VuZCIsInByZXZpb3VzQ2VsbCIsImdyb3VwTmFtZSIsInZhbHVlTmFtZSIsImdldFBvaW50IiwicmVsYXRlZFN0YXJ0IiwicmVsYXRlZEVuZCIsInZhbHVlVG9rZW4iLCJjaHVua1RleHQiLCJjb250ZW50VHlwZSIsImNvbnRlbnRUeXBlVGV4dCIsImEiLCJiIiwidGFibGUiLCJ0YWJsZUJvZHkiLCJleGl0cyIsInJlbGF0ZWQiLCJwdXNoIiwic2lkZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/micromark-extension-gfm-table/dev/lib/syntax.js\n");

/***/ })

};
;